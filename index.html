<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Vyperia’s Domain</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="icon" href="https://avatars.githubusercontent.com/u/117316014?v=4" />
    <meta property="og:title" content="Vyperia’s Domain" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://ltseverydayyou.github.io/" />
    <meta property="og:image" content="https://avatars.githubusercontent.com/u/117316014?v=4" />
    <meta name="twitter:card" content="summary_large_image" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
    <!-- BuilderIcons font parser -->
    <script defer src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
    <!-- Lua beautifier runtime -->
    <script defer src="https://blackmiaool.com/lua-beautify/lua5.1.5.min.js"></script>
    <script defer src="https://blackmiaool.com/lua-beautify/example.lua5.1.js"></script>

    <style>
        :root {
            --g1: #0b1220;
            --g2: #111c2e;
            --tx: #e7e9ee;
            --mu: #a6adbb;
            --ac: #66e3ff;
            --ac2: #a78bfa;
            --ok: #72f3b6;
            --bdA: 0.12;
            --glA: 0.06;
            --rad: 16px;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            min-height: 100%;
        }

        body {
            margin: 0;
            color: var(--tx);
            background:
                radial-gradient(1200px 600px at -10% -10%,
                    rgba(102, 227, 255, 0.12),
                    transparent 60%),
                radial-gradient(1000px 800px at 110% 120%,
                    rgba(167, 139, 250, 0.12),
                    transparent 60%),
                linear-gradient(135deg, var(--g1), var(--g2));
            font: 15px/1.45 ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica,
                Arial;
            overflow-x: hidden;
            animation: bg 22s linear infinite;
        }

        @keyframes bg {
            0% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.08);
            }

            100% {
                filter: brightness(1);
            }
        }

        .l {
            display: grid;
            grid-template-columns: 220px 1fr;
            min-height: 100svh;
            transition:
                transform 0.35s ease,
                opacity 0.25s ease;
        }

        .l.collapsed {
            transform-origin: top;
            transform: scaleY(0.05);
            opacity: 0;
            pointer-events: none;
        }

        .as {
            position: sticky;
            top: 0;
            height: 100svh;
            padding: 20px 14px;
            border-right: 1px solid rgba(255, 255, 255, var(--bdA));
            backdrop-filter: saturate(140%) blur(10px);
            background: linear-gradient(180deg,
                    rgba(255, 255, 255, 0.07),
                    rgba(255, 255, 255, 0.03));
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .br {
            padding: 6px 4px;
            font-weight: 800;
            color: var(--mu);
            letter-spacing: 0.3px;
        }

        .nb {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tb {
            appearance: none;
            border: none;
            background: transparent;
            color: var(--tx);
            text-align: left;
            padding: 10px 8px;
            font-weight: 800;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition:
                color 0.25s cubic-bezier(0.2, 0.6, 0.2, 1),
                transform 0.25s cubic-bezier(0.2, 0.6, 0.2, 1);
        }

        .tb::after {
            content: "";
            position: absolute;
            left: 8px;
            right: 70%;
            bottom: 4px;
            height: 2px;
            background: linear-gradient(90deg, var(--ac), var(--ac2));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.28s cubic-bezier(0.2, 0.6, 0.2, 1);
        }

        .tb:hover {
            transform: translateX(3px);
        }

        .tb:hover::after {
            transform: scaleX(1);
        }

        .tb.act {
            color: #fff;
        }

        .tb.act::after {
            right: 10px;
            transform: scaleX(1);
        }

        .top {
            position: relative;
            top: auto;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid rgba(255, 255, 255, var(--bdA));
            backdrop-filter: saturate(140%) blur(8px);
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.05));
            z-index: 5;
        }

        .tt {
            margin: 0;
            font-weight: 900;
            letter-spacing: 0.3px;
            background: linear-gradient(90deg, var(--ac), var(--ac2), var(--ac));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: sh 6s linear infinite;
        }

        @keyframes sh {
            0% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.22);
            }

            100% {
                filter: brightness(1);
            }
        }

        .r {
            position: absolute;
            right: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .av {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            cursor: pointer;
            transition:
                transform 0.2s,
                filter 0.2s;
        }

        .av:active {
            transform: scale(0.92);
        }

        .av.ouch {
            filter: drop-shadow(0 0 10px #ff6969);
            transform: scale(1.15);
        }

        .bb {
            position: absolute;
            bottom: calc(100% + 10px);
            right: 0;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(7, 10, 24, 0.95);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.7);
            font-size: 11px;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.82);
            white-space: nowrap;
            opacity: 0;
            transform: translateY(6px) scale(0.98);
            transform-origin: bottom right;
            pointer-events: none;
            transition: opacity 0.18s ease-out, transform 0.18s ease-out;
        }

        .bb.sh {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .ct {
            padding: 28px clamp(14px, 4vw, 32px) 60px;
        }

        .pz {
            display: flex;
            justify-content: center;
            margin: 14px 0 26px;
            animation: fade 0.8s;
        }

        @keyframes fade {
            from {
                opacity: 0;
                transform: translateY(6px);
            }

            to {
                opacity: 1;
                transform: none;
            }
        }

        .pp {
            display: none;
            opacity: 0;
            transform: translateY(8px);
            transition:
                opacity 0.35s,
                transform 0.35s;
        }

        .pp.on {
            display: block;
            opacity: 1;
            transform: none;
        }

        .pp.in {
            animation: ain 0.35s both;
        }

        .pp.out {
            animation: aout 0.32s both;
        }

        @keyframes ain {
            from {
                opacity: 0;
                transform: translateY(8px);
            }

            to {
                opacity: 1;
                transform: none;
            }
        }

        @keyframes aout {
            from {
                opacity: 1;
                transform: none;
            }

            to {
                opacity: 0;
                transform: translateY(8px);
            }
        }

        .g {
            margin: 28px auto;
            width: min(1100px, 92%);
        }

        .g h3 {
            margin: 0 0 12px;
            color: var(--ac);
            font-weight: 900;
        }

        .gr {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        }

        .home-section {
            margin-bottom: 26px;
        }

        .home-section__header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px;
        }

        .home-section__header h3 {
            margin: 0;
            font-weight: 900;
            background: linear-gradient(90deg, var(--ac), var(--ac2), var(--ac));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-size: 200% 200%;
            animation: homeGradient 6s linear infinite;
        }

        .home-section__header h3::selection {
            background: none;
        }

        .home-section__toggle {
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: var(--tx);
            padding: 4px 10px;
            border-radius: 999px;
            font-weight: 700;
            cursor: pointer;
            transition:
                transform 0.25s,
                background 0.25s;
        }

        .home-section__toggle:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.15);
        }

        .home-section__toggle:focus-visible {
            outline: 2px solid var(--ac);
            outline-offset: 2px;
        }

        .home-section__content--collapsed {
            display: none;
        }

        .tl {
            position: relative;
            padding: 12px 10px;
            border-radius: 22px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, var(--glA));
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            color: var(--tx);
            min-height: 110px;
            transform:
                perspective(600px) rotateX(0) rotateY(0) translateZ(0);
            transition:
                transform 0.45s,
                box-shadow 0.45s,
                filter 0.45s;
        }

        .tl img {
            width: 42px;
            height: 42px;
            object-fit: contain;
            filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.3));
        }

        .tl span {
            font-size: 13px;
        }

        .tl:hover {
            transform:
                perspective(600px) rotateX(5deg) rotateY(-5deg) translateY(-2px);
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
            filter: saturate(1.2);
        }

        .tl::after {
            content: attr(data-h);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 11px;
            padding: 2px 7px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            opacity: 0;
            transition:
                opacity 0.2s,
                transform 0.2s;
            pointer-events: none;
            white-space: nowrap;
        }

        .tl:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-2px);
        }

        .tl:nth-child(3n) {
            animation: f1 6s ease-in-out infinite;
        }

        .tl:nth-child(3n + 1) {
            animation: f2 7s ease-in-out infinite;
        }

        @keyframes f1 {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }

        @keyframes f2 {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(3px);
            }
        }

        @keyframes homeGradient {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .sc {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: rgba(255, 255, 255, var(--glA));
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: 16px;
            padding: 14px 16px;
            transition:
                transform 0.35s,
                box-shadow 0.35s,
                background 0.35s;
        }

        .sc:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.3);
        }

        .sc_info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .sc_img {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            object-fit: cover;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.08);
        }

        .sc_text {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            min-width: 0;
        }

        .sc.featured {
            background: linear-gradient(135deg,
                    rgba(102, 227, 255, 0.12),
                    rgba(167, 139, 250, 0.08));
            border-color: rgba(102, 227, 255, 0.45);
            box-shadow: 0 18px 40px rgba(102, 227, 255, 0.35);
        }

        .sc_badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            border-radius: 999px;
            border: 1px solid rgba(102, 227, 255, 0.6);
            padding: 2px 10px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--ac);
            background: rgba(102, 227, 255, 0.18);
        }

        .sc .nm {
            font-weight: 800;
        }

        .script-searcher {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .script-searcher__controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .script-searcher__controls input {
            flex: 1;
            min-width: 240px;
            padding: 12px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.04);
            color: var(--tx);
            font: 14px ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial;
        }

        .script-searcher__hint {
            margin: 0;
            font-size: 12px;
            color: var(--mu);
        }

        .script-searcher__panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
        }

        .script-searcher__panel {
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: 16px;
            background: rgba(255, 255, 255, var(--glA));
            padding: 16px;
        }

        .script-searcher__panel-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .script-searcher__panel-head-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .script-searcher__panel-head-group h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 700;
        }

        .script-searcher__panel-head-group span {
            font-size: 12px;
            color: var(--mu);
        }

        .script-searcher__panel-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .script-searcher__panel-controls button {
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.06);
            color: var(--tx);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .script-searcher__panel-controls button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .script-searcher__panel-page {
            font-size: 12px;
            color: var(--mu);
            min-width: 70px;
            text-align: center;
        }

        .script-searcher__grid {
            display: grid;
            gap: 14px;
        }

        .script-card {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            padding: 12px 14px;
            background: rgba(8, 12, 20, 0.5);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .script-card__thumb {
            width: 100%;
            border-radius: 10px;
            object-fit: cover;
            min-height: 140px;
            background: rgba(255, 255, 255, 0.04);
        }

        .script-card__title {
            font-weight: 700;
            color: #fff;
            text-decoration: none;
        }

        .script-card__title:focus-visible {
            outline: 2px solid var(--ac);
            outline-offset: 2px;
        }

        .script-card__meta {
            font-size: 12px;
            color: var(--mu);
        }

        .script-card__description {
            font-size: 13px;
            color: var(--tx);
            min-height: 48px;
        }

        .script-card__pills {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 11px;
        }

        .script-card__pill {
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            padding: 2px 10px;
            background: rgba(255, 255, 255, 0.06);
            color: var(--tx);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .script-card__buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .script-card__button {
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.05);
            color: var(--tx);
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            transition:
                color 0.25s ease,
                background 0.25s ease,
                opacity 0.2s ease;
        }

        .script-card__button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .script-card__stats {
            font-size: 12px;
            color: var(--mu);
        }

        .script-card__details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 6px 12px;
            margin: 4px 0;
        }

        .script-card__details dt {
            margin: 0;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--mu);
            font-weight: 700;
        }

        .script-card__details dd {
            margin: 0;
            font-size: 12px;
            color: var(--tx);
            font-weight: 600;
        }

        .script-card__details a {
            color: var(--ac);
            text-decoration: none;
        }

        .script-card__footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            font-size: 11px;
            color: var(--mu);
        }

        .script-card__link {
            font-size: 12px;
            font-weight: 700;
            color: var(--ac);
            text-decoration: none;
        }

        .script-searcher__error {
            font-size: 12px;
            color: #f08;
            min-height: 18px;
        }

        .script-searcher__empty {
            font-size: 12px;
            color: var(--mu);
            padding: 10px;
            border-radius: 10px;
            border: 1px dashed rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.02);
        }

        .bn {
            position: relative;
            overflow: hidden;
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 900;
            cursor: pointer;
            transition:
                transform 0.2s,
                filter 0.2s,
                background 0.2s;
        }

        .bn:active {
            transform: translateY(1px);
        }

        .bn.cp {
            background: var(--ok);
            color: #0b1220;
        }

        .bn.gm {
            background: linear-gradient(90deg, var(--ac), var(--ac2));
            color: #0b1220;
        }

        .bn.vw {
            background: linear-gradient(90deg, var(--ac), var(--ac2));
            color: #0b1220;
        }

        .brw {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .rp {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            background: radial-gradient(circle at center,
                    rgba(255, 255, 255, 0.6) 0%,
                    rgba(255, 255, 255, 0.2) 40%,
                    rgba(255, 255, 255, 0) 70%);
            animation: rip 0.6s ease-out forwards;
        }

        @keyframes rip {
            from {
                width: 0;
                height: 0;
                opacity: 0.9;
            }

            to {
                width: 260px;
                height: 260px;
                opacity: 0;
            }
        }

        .md {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            padding: 32px 16px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(18px);
            opacity: 0;
            pointer-events: none;
            transform: translateY(6px) scale(1.01);
            transition: opacity 0.18s ease-out, transform 0.2s ease-out;
            z-index: 80;
        }

        .md.sh {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0) scale(1);
        }

        .mc {
            width: min(900px, 92vw);
            max-height: 86vh;
            overflow: auto;
            background: linear-gradient(180deg,
                    rgba(22, 28, 42, 0.95),
                    rgba(12, 16, 26, 0.95));
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: 18px;
            transform: translateY(10px) scale(0.98);
            transition: transform 0.35s;
        }

        .md.sh .mc {
            transform: none;
        }

        .mh {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            position: sticky;
            top: 0;
            background: linear-gradient(180deg,
                    rgba(12, 16, 26, 0.9),
                    rgba(12, 16, 26, 0.7));
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255, 255, 255, var(--bdA));
        }

        .x {
            background: transparent;
            border: none;
            color: var(--mu);
            font-size: 20px;
            width: 40px;
            height: 40px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
            overflow: hidden;
        }

        .x:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        pre {
            margin: 0;
            padding: 16px;
            max-height: 70vh;
            overflow: auto;
        }

        .sk {
            height: 220px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.06);
            position: relative;
            overflow: hidden;
        }

        .sk::before {
            content: "";
            position: absolute;
            inset: -20%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.14),
                    transparent);
            animation: shm 1.2s ease-in-out infinite;
        }

        @keyframes shm {
            from {
                transform: translateX(-60%);
            }

            to {
                transform: translateX(60%);
            }
        }

        .ed {
            background: rgba(255, 255, 255, var(--glA));
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: 16px;
            padding: 12px;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            resize: vertical;
            border-radius: 12px;
            border: 1px dashed rgba(255, 255, 255, var(--bdA));
            padding: 12px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--tx);
            font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .if {
            width: 100%;
            height: 360px;
            background: #fff;
            border: none;
            border-radius: 12px;
            resize: vertical;
            overflow: auto;
            min-height: 160px;
        }

        .cs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .html-lab {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .html-lab__header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .html-lab__header p {
            margin: 6px 0 0;
            color: var(--mu);
            max-width: 520px;
        }

        .html-lab__status {
            font-size: 13px;
            color: var(--mu);
            white-space: nowrap;
        }

        .html-lab__actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            width: 100%;
        }

        .html-lab__actions .pl {
            font-size: 13px;
            letter-spacing: 0.02em;
            text-transform: none;
            justify-content: center;
        }

        .html-lab__panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 16px;
        }

        .html-lab__panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--rad);
            padding: 14px;
        }

        .html-lab__panel textarea {
            min-height: 260px;
        }

        .html-lab__panel iframe {
            min-height: 260px;
        }

        .html-lab__panel-title {
            font-size: 13px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--mu);
        }

        .html-lab__structure {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--rad);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .html-lab__structure-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 13px;
            color: var(--mu);
        }

        .html-lab__structure-tree {
            max-height: 360px;
            overflow: auto;
            padding-right: 6px;
        }

        .html-tree__node {
            border-left: 2px solid rgba(255, 255, 255, 0.08);
            margin-left: 10px;
            padding-left: 10px;
        }

        .html-tree__node summary {
            cursor: pointer;
            color: var(--tx);
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 13px;
        }

        .html-tree__text,
        .html-tree__comment {
            margin-left: 22px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 12px;
            color: var(--mu);
        }

        .html-tree__comment {
            color: #7dd3fc;
        }

        .html-tree__closing {
            margin-left: 22px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            color: rgba(255, 255, 255, 0.65);
            font-size: 12px;
        }

          .html-lab__structure-empty {
            margin: 0;
            font-size: 13px;
            color: var(--mu);
          }

          .rdd {
            display: flex;
            flex-direction: column;
            gap: 20px;
          }

          .rdd-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
          }

          .rdd-header p {
            margin: 4px 0 0;
            color: var(--mu);
          }

          .rdd-link-out {
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 999px;
            padding: 8px 16px;
            font-weight: 700;
            text-decoration: none;
            color: var(--ac);
            transition: border-color 0.2s ease, color 0.2s ease;
          }

          .rdd-link-out:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
          }

          .rdd-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
          }

          .rdd-card {
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.02);
            display: flex;
            flex-direction: column;
            gap: 14px;
          }

          .rdd-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
          }

          .rdd-field label,
          .rdd-field span {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--mu);
          }

          .rdd-field input,
          .rdd-field select {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.02);
            color: var(--tx);
            font: 14px ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial;
          }

          .rdd-toggles {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
          }

          .rdd-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 10px 12px;
          }

          .rdd-actions {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
          }

          .rdd-actions button {
            width: 100%;
          }

          .rdd-link-preview {
            font-size: 13px;
            word-break: break-all;
            border: 1px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
          }

        .pl {
            position: relative;
            overflow: hidden;
            border: none;
            border-radius: 999px;
            padding: 10px 14px;
            font-weight: 900;
            cursor: pointer;
            color: #0b1220;
            background: #fff;
            transition:
                transform 0.2s,
                background 0.2s;
        }

        .pl.sc {
            background: var(--ok);
        }

        .ts {
            position: fixed;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%) translateY(10px);
            background: rgba(15, 15, 22, 0.96);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 10px 14px;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition:
                opacity 0.35s,
                transform 0.35s;
            z-index: 60;
        }

        .ts.sh {
            opacity: 1;
            transform: translateX(-50%);
        }

        .th {
            display: grid;
            gap: 14px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .fi {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: rgba(255, 255, 255, var(--glA));
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: var(--rad);
            padding: 10px 12px;
        }

        .fi input[type="color"] {
            width: 42px;
            height: 32px;
            border: none;
            background: transparent;
        }

        .fi input[type="range"] {
            width: 50%;
        }

        .fi input[type="number"] {
            width: 70px;
        }

        .versions-panel__header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }

        .versions-panel__header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .versions-panel__intro {
            font-size: 13px;
            color: var(--mu);
            margin: 2px 0 0;
            max-width: 640px;
        }

        .version-card__docs {
            font-size: 12px;
            color: var(--ac2);
            text-decoration: none;
            letter-spacing: 0.08em;
        }

        .version-card__docs:hover {
            text-decoration: underline;
        }

        .version-card__status {
            font-size: 11px;
            color: var(--mu);
            margin-top: 6px;
        }

        .versions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .version-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: var(--rad);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 220px;
        }

        .version-card__head {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            align-items: flex-start;
        }

        .version-card__title {
            margin: 0;
            font-weight: 900;
            letter-spacing: 0.08em;
            font-size: 15px;
            text-transform: uppercase;
            color: var(--ac);
        }

        .version-card__desc {
            margin: 2px 0 0;
            font-size: 12px;
            color: var(--mu);
        }

        .version-card__refresh {
            border: none;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--tx);
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .version-card__refresh:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.16);
        }

        .version-card__body dl,
        .executor-card__body dl {
            margin: 0;
            display: grid;
            gap: 6px 10px;
            grid-template-columns: auto 1fr;
        }

        .version-card__body dt,
        .executor-card__body dt {
            font-size: 11px;
            letter-spacing: 0.08em;
            color: var(--mu);
            text-transform: uppercase;
        }

        .version-card__body dd,
        .executor-card__body dd {
            margin: 0;
            font-size: 14px;
            font-weight: 700;
            color: var(--tx);
            word-break: break-word;
        }

        .version-card__placeholder,
        .executor-card__placeholder {
            font-size: 13px;
            color: var(--mu);
        }

        .executor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .executor-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            border-radius: var(--rad);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 220px;
        }

        .executor-card__title {
            margin: 0;
            font-weight: 800;
            font-size: 16px;
            flex: 1;
        }

        .executor-card__meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .executor-card__meta-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .executor-card__type {
            font-size: 12px;
            color: var(--mu);
            text-transform: uppercase;
        }

        .executor-card__pills {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .executor-card__pill {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.06);
            color: var(--tx);
        }

        .executor-card__pill--good {
            background: rgba(114, 243, 182, 0.2);
            color: #0d2114;
        }

        .executor-card__pill--warn {
            background: rgba(255, 132, 132, 0.3);
            color: #2d0808;
        }

        .executor-card__pill--info {
            background: rgba(166, 173, 187, 0.2);
            color: var(--mu);
        }

        .executor-card__status-pill {
            padding: 3px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #0b1220;
            background: rgba(114, 243, 182, 0.7);
            box-shadow: 0 0 10px rgba(114, 243, 182, 0.5);
        }

        .executor-card__status-pill--down {
            background: rgba(255, 132, 132, 0.9);
            color: #2d0808;
            box-shadow: 0 0 10px rgba(255, 132, 132, 0.6);
        }

        .executor-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .executor-tab {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.04);
            color: var(--tx);
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.12em;
            padding: 6px 14px;
            border-radius: 999px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .executor-tab--active {
            border-color: rgba(102, 227, 255, 0.8);
            background: rgba(102, 227, 255, 0.15);
        }

        .executor-divider {
            margin: 18px 0 8px;
            font-size: 12px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--mu);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }

        .executor-card__links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .executor-card__links a {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--ac);
        }

        .version-card__error,
        .executor-card__error {
            color: #ff8484;
            font-size: 13px;
            margin: 0;
        }

        /* BuilderIcons tab styling */

        #bi-root {
            margin-top: 10px;
        }

        #bi-loading-screen {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 18px 0;
        }

        #bi-loading-spinner {
            border: 6px solid rgba(255, 255, 255, 0.08);
            border-top: 6px solid var(--ac);
            border-radius: 50%;
            width: 64px;
            aspect-ratio: 1 / 1;
            animation: bi-loading-spin 1s linear infinite;
        }

        #bi-loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: var(--mu);
        }

        @keyframes bi-loading-spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #bi-root {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .bi-toolbar {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .bi-toolbar__search {
            flex: 1;
            min-width: 220px;
        }

        .bi-toolbar__input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.02);
            color: var(--tx);
            font: 14px ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial;
            transition:
                border-color 0.2s ease,
                background 0.2s ease,
                box-shadow 0.2s ease;
        }

        .bi-toolbar__input:focus-visible {
            outline: none;
            border-color: rgba(102, 227, 255, 0.8);
            background: rgba(255, 255, 255, 0.04);
            box-shadow: 0 0 0 2px rgba(102, 227, 255, 0.2);
        }

        .bi-toolbar__input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .bi-toolbar__input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .bi-toolbar__hint {
            font-size: 13px;
            color: var(--mu);
        }

        .bi-grid-wrap {
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, var(--bdA));
            background: rgba(255, 255, 255, 0.02);
            padding: 6px;
            max-height: min(70vh, 75svh);
            overflow: auto;
        }

        .bi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .bi-grid__empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 28px 16px;
            border-radius: 12px;
            border: 1px dashed rgba(255, 255, 255, var(--bdA));
            color: var(--mu);
            font-size: 14px;
        }

        .bi-entry {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: linear-gradient(220deg,
                    rgba(255, 255, 255, 0.02),
                    rgba(255, 255, 255, 0.005));
        }

        .bi-entry:hover {
            border-color: rgba(255, 255, 255, 0.4);
        }

        .bi-entry__glyphs {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .bi-entry__glyph {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            display: grid;
            place-items: center;
            font-family: BuilderIcons, ui-sans-serif;
            font-size: 32px;
            background: rgba(255, 255, 255, 0.04);
        }

        .bi-entry__glyph--bold {
            font-weight: 700;
        }

        .bi-entry__meta {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--mu);
        }

        .bi-entry__name {
            font-weight: 600;
            font-size: 15px;
            line-height: 1.2;
            word-break: break-word;
        }

        .bi-entry__components {
            color: var(--mu);
            font-size: 13px;
            min-height: 44px;
            line-height: 1.4;
            word-break: break-word;
        }

        .bi-entry__glyph-labels {
            display: flex;
            justify-content: center;
            gap: 18px;
            font-size: 12px;
            color: var(--mu);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .bi-entry__glyph-labels span {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .bi-entry__actions {
            display: flex;
            justify-content: flex-end;
        }

        .bi-entry__copy {
            font-size: 14px;
            padding: 8px 12px;
        }

        .bi-entry__copy--success {
            background: var(--ok);
            color: #051014;
        }

        #pb.bi-fullscreen {
            position: fixed;
            inset: 0;
            padding: 36px;
            z-index: 1300;
            background: rgba(4, 6, 12, 0.96);
            overflow: auto;
        }

        #pb.bi-fullscreen .g.ed {
            width: min(1200px, 100%);
            margin: 0 auto;
            padding: 0;
        }

        #pb.bi-fullscreen h3 {
            margin-top: 0;
        }

        #pb.bi-fullscreen .bi-grid-wrap {
            height: min(70vh, calc(100vh - 220px));
            max-height: none;
        }

        #pb.bi-fullscreen .bi-toolbar {
            justify-content: flex-end;
        }

        body.bi-buildericons-fullscreen {
            overflow: hidden;
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        @media (max-width: 1080px) {
            .l {
                grid-template-columns: 1fr;
            }

            .as {
                position: relative;
                gap: 18px;
            }

            .nb {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .as-actions {
                width: 100%;
                justify-content: flex-start;
            }

            .tb {
                width: auto;
            }
        }

        :root {
            --g1: #050614;
            --g2: #050a1f;
            --tx: #f6f7ff;
            --mu: #9aa0c3;
            --ac: #6e91ff;
            --ac2: #ff7ad9;
            --ok: #60f0c3;
            --bdA: 0.18;
            --glA: 0.1;
            --panel: rgba(10, 12, 26, 0.9);
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                "SF Pro Display", "Inter", sans-serif;
            background:
                radial-gradient(circle at top left, #15162b 0, transparent 52%),
                radial-gradient(circle at bottom right, #2a1242 0, transparent 55%),
                linear-gradient(145deg, #050614 0, #05071c 40%, #17143a 100%);
            color: #f5f5ff;
            min-height: 100vh;
            height: auto;
        }

        body::before,
        body::after {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                linear-gradient(120deg, rgba(255, 255, 255, 0.07), transparent 60%),
                url("data:image/svg+xml,%3Csvg width='80' height='80' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' stroke='rgba(255,255,255,0.08)' stroke-width='0.5'%3E%3Cpath d='M0 40h80M40 0v80'/%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.25;
            z-index: -1;
        }

        body::after {
            background: radial-gradient(circle at 60% 40%, rgba(110, 145, 255, 0.3), transparent 50%);
            opacity: 0.4;
        }

        .l {
            display: grid;
            grid-template-columns: 320px minmax(0, 1fr);
            align-items: flex-start;
            gap: clamp(20px, 3vw, 36px);
            width: min(1200px, calc(100% - 40px));
            margin: 0 auto;
            padding: clamp(18px, 4vw, 48px) 0 80px;
        }

        .as {
            position: sticky;
            top: clamp(12px, 3vw, 24px);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: clamp(14px, 3vw, 32px);
            padding: clamp(12px, 2vw, 22px) clamp(16px, 3vw, 28px);
            border-radius: 28px;
            backdrop-filter: blur(16px) saturate(160%);
            background: rgba(4, 5, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 25px 60px rgba(3, 5, 12, 0.45);
        }

        .brand-block {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .brand-icon {
            width: 46px;
            height: 46px;
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(110, 145, 255, 0.4), rgba(255, 122, 217, 0.4));
            display: grid;
            place-items: center;
            overflow: visible;
            position: relative;
        }

        .brand-icon__link {
            display: inline-flex;
            width: 100%;
            height: 100%;
            border-radius: 14px;
            overflow: hidden;
            cursor: pointer;
        }

        .brand-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .brand-copy {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .brand-label {
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #fff;
            font-size: 13px;
        }

        .brand-copy p {
            margin: 0;
            color: var(--mu);
            font-size: 13px;
        }

        .nb {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            width: 100%;
        }

        .tb {
            border: 1px solid transparent;
            border-radius: 999px;
            padding: 8px 18px;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.08em;
            background: rgba(255, 255, 255, 0.04);
            color: var(--mu);
            width: 100%;
            text-align: center;
        }

        .tb:hover {
            color: #fff;
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .tb.act {
            background: linear-gradient(135deg, var(--ac), var(--ac2));
            color: #040614;
            border-color: transparent;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
        }

        .top {
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 32px;
            background: rgba(5, 8, 20, 0.82);
            padding: clamp(20px, 4vw, 40px);
            margin-top: 10px;
            box-shadow: 0 35px 120px rgba(4, 5, 12, 0.6);
        }

        .hero {
            display: grid;
            grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
            gap: clamp(24px, 4vw, 40px);
            align-items: flex-start;
        }

        .hero__eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.3em;
            font-size: 12px;
            color: var(--mu);
            margin: 0 0 10px;
        }

        .hero__body {
            margin: 14px 0 18px;
            font-size: 16px;
            color: rgba(246, 247, 255, 0.85);
        }

        .hero__actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn {
            border-radius: 999px;
            padding: 10px 20px;
            font-weight: 700;
            text-decoration: none;
            background: linear-gradient(135deg, var(--ac), var(--ac2));
            color: #05070f;
            box-shadow: 0 12px 30px rgba(110, 145, 255, 0.45);
        }

        .btn--ghost {
            background: transparent;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: none;
        }

        .hero__stats {
            display: flex;
            gap: 18px;
            margin-top: 24px;
        }

        .hero__stats div {
            flex: 1;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 14px;
        }

        .hero__stats dt {
            margin: 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--mu);
        }

        .hero__stats dd {
            margin: 6px 0 0;
            font-size: 26px;
            font-weight: 700;
        }

        .hero__cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
            gap: 16px;
        }

        .hero-card {
            border-radius: 26px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(13, 15, 30, 0.9);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .hero-card__kicker {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 11px;
            color: var(--mu);
        }

        .hero-card h3 {
            margin: 0;
            font-size: 18px;
        }

        .hero-card p {
            margin: 0;
            color: rgba(246, 247, 255, 0.75);
        }

        .hero-card a {
            color: var(--ac);
            text-decoration: none;
            font-weight: 700;
        }

        .hero-card--alert {
            background: linear-gradient(140deg, rgba(255, 122, 217, 0.22), rgba(13, 15, 30, 0.92));
        }

        .hero-card--sponsor {
            background: linear-gradient(140deg, rgba(110, 145, 255, 0.2), rgba(13, 15, 30, 0.92));
        }

        .hero-card--discord {
            background: linear-gradient(140deg, rgba(96, 240, 195, 0.16), rgba(13, 15, 30, 0.92));
        }

        .broadcast {
            margin-top: 18px;
            padding: 16px 20px;
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(8, 10, 20, 0.8);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .broadcast__label {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 11px;
            color: var(--mu);
        }

        .broadcast__link {
            margin-left: auto;
            color: var(--ac);
            text-decoration: none;
            font-weight: 600;
        }

        .ct {
            padding: clamp(18px, 4vw, 32px) 0 60px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .pz {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            background: rgba(8, 10, 20, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 22px;
            padding: clamp(12px, 2vw, 20px);
        }

        .presence-card__meta {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .presence-card__eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 11px;
            color: var(--mu);
        }

        .presence-card__meta strong {
            font-size: 20px;
        }

        .pz img {
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
            display: block;
        }

        .g {
            width: 100%;
            margin: 0 0 32px;
        }

        .home-section {
            background: var(--panel);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: clamp(18px, 3vw, 28px);
            box-shadow: 0 18px 60px rgba(3, 5, 12, 0.55);
        }

        .home-section__header {
            margin-bottom: 16px;
        }

        .home-section__toggle {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .gr {
            gap: 18px;
        }

        .tl {
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(10, 12, 26, 0.9);
        }

        .ed {
            background: var(--panel);
            border-radius: 28px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 30px 90px rgba(2, 4, 10, 0.7);
            padding: clamp(18px, 3vw, 28px);
        }

        @media (max-width: 1250px) {
            .hero {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 1100px) {
            .hero {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 780px) {
            .hero__stats {
                flex-direction: column;
            }

            .nb {
                width: 100%;
            }

            .broadcast {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 520px) {
            .as-actions {
                flex-direction: column;
                align-items: flex-start;
            }

            .hero__actions {
                flex-direction: column;
                align-items: stretch;
            }

            .pz {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 960px) {
            .l {
                grid-template-columns: 1fr;
                width: min(100%, calc(100% - 24px));
                padding: clamp(16px, 6vw, 32px) clamp(12px, 5vw, 20px) 60px;
                gap: clamp(16px, 4vw, 28px);
            }

            .as {
                position: static;
                width: 100%;
            }

            .nb {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 12px;
            }

            .tb {
                width: auto;
                flex: 1 1 calc(50% - 12px);
            }

            main {
                width: 100%;
            }
        }

        @media (max-width: 640px) {
            .tb {
                flex: 1 1 100%;
                width: 100%;
            }

            .tt {
                font-size: clamp(28px, 9vw, 40px);
            }

            .brand-block {
                flex-direction: column;
                align-items: flex-start;
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="l" id="l">
        <aside class="as">
            <div class="brand-block">
                <div class="brand-icon">
                    <img id="av" class="av" src="https://avatars.githubusercontent.com/u/117316014?v=4" alt="Vyperia avatar" />
                    <div id="bb" class="bb"></div>
                </div>
                <div class="brand-copy">
                    <span class="brand-label">Vyperia’s Domain</span>
                    <p>
                        <a href="https://discord.com/invite/zzjYhtMGFD" target="_blank" rel="noopener noreferrer">
                            Nameless Admin Discord
                        </a>
                    </p>
                </div>
            </div>
            <nav class="nb" id="nb">
                <button class="tb act" data-t="h">Home</button>
                <button class="tb" data-t="s">Scripts</button>
                <button class="tb" data-t="x">Script Searcher</button>
                <button class="tb" data-t="l">Lua</button>
                <button class="tb" data-t="w">HTML</button>
                <button class="tb" data-t="t">Theme</button>
                <button class="tb" data-t="v">Versions</button>
                <button class="tb" data-t="e">Executors</button>
                <button class="tb" data-t="r">RDD</button>
                <button class="tb" data-t="b">Roblox BuilderIcons</button>
            </nav>
        </aside>

        <main>
            <h1 class="tt">Vyperia’s Domain</h1>



            <div class="pz">
                <div class="presence-card__meta">
                    <span class="presence-card__eyebrow">Live Discord presence</span>
                    <strong>@ltseverydayyou</strong>
                    <p>Powered by Lanyard</p>
                </div>
                <a href="https://discord.com/users/641335879381680129" target="_blank" rel="noopener">
                    <img src="https://lanyard.cnrad.dev/api/641335879381680129?theme=dark&animated=true" height="150" alt="discord" />
                </a>
            </div>

            <section id="ph" class="pp on">
                <div id="home_sections"></div>
            </section>

            <section id="ps" class="pp">
                <div class="g" id="sc_list"></div>
            </section>

            <section id="pl" class="pp">
                <div class="g ed">
                    <h3>Lua</h3>
                    <textarea id="li" placeholder="Paste Lua code here..."></textarea>
                    <div class="cs">
                        <button class="pl" id="lhl">Highlight</button>
                        <button class="pl sc" id="lbf">Beautify</button>
                    </div>
                    <pre>
<code id="lo" class="language-lua">-- Highlighted code will appear here</code>
              </pre>
                </div>
            </section>

            <section id="pw" class="pp">
                <div class="g ed html-lab">
                    <div class="html-lab__header">
                        <div>
                            <h3>HTML playground</h3>
                            <p>Inspired by html.onlineviewer.net &mdash; live preview, formatting, highlighting, sample snippets, and import/export in one place.</p>
                        </div>
                        <p id="html-lab-status" class="html-lab__status">Waiting for input</p>
                    </div>
                    <div class="html-lab__actions" role="group" aria-label="HTML utilities">
                        <button class="pl sc" id="hr" type="button">Update preview</button>
                        <button class="pl" id="html-preview-window" type="button">Preview (Full page)</button>
                        <button class="pl" id="html-highlight-window" type="button">Highlight (Full page)</button>
                        <button class="pl" id="html-format" type="button">Format</button>
                        <button class="pl" id="html-expand" type="button">Expand all</button>
                        <button class="pl" id="html-collapse" type="button">Collapse all</button>
                        <button class="pl" id="html-sample" type="button">Sample</button>
                        <button class="pl" id="html-clear" type="button">Clear</button>
                        <button class="pl" id="html-import-trigger" type="button">Import</button>
                        <button class="pl" id="html-export" type="button">Export</button>
                        <input type="file" id="html-import" hidden accept=".html,.htm,text/*" />
                    </div>
                    <div class="html-lab__panels">
                        <label class="html-lab__panel">
                            <span class="html-lab__panel-title">Editor</span>
                            <textarea id="hi" placeholder="Paste or type HTML here..." spellcheck="false"></textarea>
                        </label>
                        <div class="html-lab__panel">
                            <div class="html-lab__panel-title">Live preview</div>
                            <iframe id="ho" class="if" title="HTML preview"></iframe>
                        </div>
                    </div>
                    <div class="html-lab__structure">
                        <div class="html-lab__structure-head">
                            <div>
                                <strong>Structure view</strong>
                                <span id="html-structure-summary"></span>
                            </div>
                            <button class="pl" type="button" id="html-refresh-structure">Sync view</button>
                        </div>
                        <div id="html-structure" class="html-lab__structure-tree" aria-live="polite"></div>
                    </div>
                </div>
            </section>

            <section id="pt" class="pp">
                <div class="g ed">
                    <h3>Theme</h3>
                    <div class="th">
                        <div class="fi">
                            <span>Accent</span>
                            <input id="c_ac" type="color" value="#66e3ff" />
                        </div>
                        <div class="fi">
                            <span>Accent 2</span>
                            <input id="c_ac2" type="color" value="#a78bfa" />
                        </div>
                        <div class="fi">
                            <span>BG 1</span>
                            <input id="c_g1" type="color" value="#0b1220" />
                        </div>
                        <div class="fi">
                            <span>BG 2</span>
                            <input id="c_g2" type="color" value="#111c2e" />
                        </div>
                        <div class="fi">
                            <span>Glass</span>
                            <input id="r_gl" type="range" min="0" max="0.3" step="0.01" value="0.06" />
                        </div>
                        <div class="fi">
                            <span>Border</span>
                            <input id="r_bd" type="range" min="0" max="0.3" step="0.01" value="0.12" />
                        </div>
                        <div class="fi">
                            <span>Radius</span>
                            <input id="n_rad" type="number" min="8" max="30" step="1" value="16" />
                        </div>
                        <div class="fi">
                            <span>Font px</span>
                            <input id="n_fs" type="number" min="12" max="20" step="1" value="15" />
                        </div>
                    </div>
                    <div class="cs">
                        <button class="pl" id="t_apply">Apply</button>
                        <button class="pl sc" id="t_save">Save</button>
                        <button class="pl" id="t_reset">Reset</button>
                    </div>
                </div>
            </section>

            <section id="pv" class="pp">
                <div class="g ed">
                    <div class="versions-panel__header">
                        <h3>Roblox versions</h3>
                        <a class="version-card__docs" href="https://docs.weao.xyz/weao-api-reference/roblox-versions" target="_blank" rel="noopener noreferrer">
                            Docs
                        </a>
                    </div>
                    <p class="versions-panel__intro">
                        Realtime release data for current, future, and past Roblox builds powered by the WEAO API.
                    </p>
                    <div id="versions-grid" class="versions-grid"></div>
                </div>
            </section>

            <section id="pe" class="pp">
                <div class="g ed">
                    <div class="versions-panel__header">
                        <div>
                            <h3>Executor statuses</h3>
                            <p class="versions-panel__intro">
                                Live sUNC/UNC, detected, and platform details for every tracked executor.
                            </p>
                        </div>
                        <div class="versions-panel__header-controls">
                            <a class="version-card__docs" href="https://docs.weao.xyz/weao-api-reference/exploits" target="_blank" rel="noopener noreferrer">
                                Docs
                            </a>
                            <button class="version-card__refresh" type="button" id="executor-refresh">
                                Refresh
                            </button>
                        </div>
                    </div>
                    <div class="executor-tabs" role="tablist">
                        <button type="button" class="executor-tab executor-tab--active" data-filter="all">
                            All
                        </button>
                        <button type="button" class="executor-tab" data-filter="windows">
                            Windows
                        </button>
                        <button type="button" class="executor-tab" data-filter="mac">
                            MAC
                        </button>
                        <button type="button" class="executor-tab" data-filter="android">
                            Android
                        </button>
                        <button type="button" class="executor-tab" data-filter="ios">
                            iOS
                        </button>
                    </div>
                    <div id="executor-status" class="version-card__status">
                        Waiting for data...
                    </div>
                    <div id="executor-grid" class="executor-grid"></div>
                </div>
            </section>

            <section id="px" class="pp">
                <div class="g ed">
                    <h3>Script Searcher</h3>
                    <div class="script-searcher" id="script-searcher">
                        <div class="script-searcher__controls">
                            <input id="script-search-query" type="search" placeholder="Search titles, authors, or games" />
                            <button class="pl sc" id="script-search-btn" type="button">
                                Search
                            </button>
                        </div>
                        <p class="script-searcher__hint">
                            Results powered by Rscripts and ScriptBlox APIs.
                        </p>
                        <div class="script-searcher__panels">
                            <div class="script-searcher__panel">
                                <div class="script-searcher__panel-head">
                                    <div class="script-searcher__panel-head-group">
                                        <h3>Rscripts</h3>
                                        <span id="script-search-rscripts-meta"></span>
                                    </div>
                                    <div class="script-searcher__panel-controls">
                                        <button type="button" id="script-search-rscripts-prev" aria-label="Previous Rscripts page">
                                            Prev
                                        </button>
                                        <span id="script-search-rscripts-page" class="script-searcher__panel-page">
                                            Page 1
                                        </span>
                                        <button type="button" id="script-search-rscripts-next" aria-label="Next Rscripts page">
                                            Next
                                        </button>
                                    </div>
                                </div>
                                <div id="script-search-rscripts-error" class="script-searcher__error" aria-live="polite"></div>
                                <div id="script-search-rscripts" class="script-searcher__grid"></div>
                            </div>
                            <div class="script-searcher__panel">
                                <div class="script-searcher__panel-head">
                                    <div class="script-searcher__panel-head-group">
                                        <h3>ScriptBlox</h3>
                                        <span id="script-search-scriptblox-meta"></span>
                                    </div>
                                    <div class="script-searcher__panel-controls">
                                        <button type="button" id="script-search-scriptblox-prev" aria-label="Previous ScriptBlox page">
                                            Prev
                                        </button>
                                        <span id="script-search-scriptblox-page" class="script-searcher__panel-page">
                                            Page 1
                                        </span>
                                        <button type="button" id="script-search-scriptblox-next" aria-label="Next ScriptBlox page">
                                            Next
                                        </button>
                                    </div>
                                </div>
                                <div id="script-search-scriptblox-error" class="script-searcher__error" aria-live="polite"></div>
                                <div id="script-search-scriptblox" class="script-searcher__grid"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Roblox BuilderIcons tab -->
            <section id="pr" class="pp">
                <div class="g ed rdd">
                    <div class="rdd-header">
                        <div>
                            <h3>RDD versions downloader</h3>
                            <p>Build download links for Roblox deployments without leaving this site. Buttons below open <strong>ltseverydayyou.github.io/rdd</strong> with the right query parameters so you still get the full experience from the official tool.</p>
                        </div>
                        <a class="rdd-link-out" href="https://ltseverydayyou.github.io/rdd" target="_blank" rel="noopener">Open ltseverydayyou.github.io/rdd</a>
                    </div>
                    <div class="rdd-grid">
                        <div class="rdd-card">
                            <div class="rdd-field">
                                <span>Binary type</span>
                                <select id="rdd-binary">
                                    <option value="WindowsPlayer">WindowsPlayer (Player)</option>
                                    <option value="WindowsStudio64">WindowsStudio64 (Studio)</option>
                                    <option value="MacPlayer">MacPlayer</option>
                                    <option value="MacStudio">MacStudio</option>
                                </select>
                            </div>
                            <div class="rdd-field">
                                <span>Channel</span>
                                <input id="rdd-channel" type="text" placeholder="LIVE" />
                            </div>
                            <div class="rdd-field">
                                <span>Version hash (optional)</span>
                                <input id="rdd-version" type="text" placeholder="version-xxxxxxxxxxxxxxxx" />
                            </div>
                            <div class="rdd-field">
                                <span>Compression level</span>
                                <input id="rdd-compression" type="number" min="1" max="9" value="5" />
                            </div>
                            <div class="rdd-toggles">
                                <label class="rdd-toggle" for="rdd-compress">
                                    <input id="rdd-compress" type="checkbox" />
                                    <span>Compress zip output</span>
                                </label>
                                <label class="rdd-toggle" for="rdd-launcher">
                                    <input id="rdd-launcher" type="checkbox" />
                                    <span>Include launcher (Windows)</span>
                                </label>
                            </div>
                            <div class="rdd-actions">
                                <button class="pl sc" type="button" id="rdd-download-specific">Download version</button>
                                <button class="pl" type="button" id="rdd-download-latest">Latest build</button>
                                <button class="pl" type="button" id="rdd-download-previous">Previous build</button>
                                <button class="pl" type="button" id="rdd-copy-link">Copy permanent link</button>
                            </div>
                        </div>
                        <div class="rdd-card">
                            <h4>Link preview</h4>
                            <p>Fill in the fields to generate the same permanent link that RDD uses. Share it with teammates or bookmark it for later.</p>
                            <div class="rdd-link-preview" id="rdd-link-preview">Add a version hash or use one of the quick buttons to generate a link.</div>
                            <p id="rdd-status" class="rdd-link-preview" style="margin-top: 12px;" aria-live="polite">Ready.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="pb" class="pp">
                <div class="g ed">
                    <h3>Roblox BuilderIcons</h3>
                    <div id="bi-root">
                        <div id="bi-loading-screen">
                            <div id="bi-loading-spinner"></div>
                            <p id="bi-loading-text"></p>
                        </div>

                        <div class="bi-toolbar">
                            <div class="bi-toolbar__search">
                                <input id="bi-search" class="bi-toolbar__input" type="search" placeholder="Search icons by name or components" aria-label="Search BuilderIcons" autocomplete="off" spellcheck="false" disabled />
                            </div>
                            <span class="bi-toolbar__hint">Loading BuilderIcons...</span>
                            <button class="pl sc" type="button" id="bi-fullscreen-toggle">
                                Full screen
                            </button>
                        </div>

                        <div class="bi-grid-wrap">
                            <div id="bi-grid" class="bi-grid" role="list" aria-label="BuilderIcons glyphs"></div>
                        </div>
                    </div>
                </div>
            </section>
    </div>
    </main>
    </div>

    <audio id="fx" preload="auto">
        <source src="get-out.mp3" type="audio/mpeg" />
    </audio>
    <div id="ts" class="ts"></div>

    <div id="md" class="md" aria-hidden="true">
        <div class="mc">
            <div class="mh">
                <strong id="mt" class="br">LoadingвЂ¦</strong>
                <div>
                    <button class="bn cp" id="cp">Copy Script</button>
                    <button class="x" id="x">✕</button>
                </div>
            </div>
            <div id="mb" class="sk"></div>
        </div>
    </div>

    <script>
        const q = (s) => document.querySelector(s);
          const qa = (s) => document.querySelectorAll(s);
          const debounce = (fn, wait = 250) => {
            let timeout;
            return (...args) => {
              clearTimeout(timeout);
              timeout = setTimeout(() => fn.apply(null, args), wait);
            };
          };

          const host = (s) => {
            try {
              return new URL(s).host.replace(/^www\./, "");
            } catch {
              return "";
            }
          };

          const luaBeautifier = {
            initPromise: null,
            state: null
          };

          function resetLuaBeautifier() {
            if (luaBeautifier.state?.C && luaBeautifier.state?.L) {
              try {
                luaBeautifier.state.C.lua_close(luaBeautifier.state.L);
              } catch {
                // ignore cleanup errors
              }
            }
            luaBeautifier.state = null;
            luaBeautifier.initPromise = null;
          }

          function initLuaBeautifier() {
            if (luaBeautifier.initPromise) {
              return luaBeautifier.initPromise;
            }

            luaBeautifier.initPromise = new Promise((resolve, reject) => {
            if (!window.Lua5_1 || !Lua5_1.C) {
                resetLuaBeautifier();
                reject(new Error("Lua beautifier runtime unavailable"));
                return;
              }

              try {
                const C = Lua5_1.C;
                const state = {
                  C,
                  L: C.lua_open(),
                  output: "",
                  outputRef: null
                };
                C.luaL_openlibs(state.L);
                state.outputRef = Lua5_1.Runtime.addFunction(function (ctx) {
                  const str = C.luaL_checkstring(ctx, 1);
                  state.output = str;
                  return 0;
                });
                C.lua_pushcfunction(state.L, state.outputRef);
                C.lua_setglobal(state.L, "OUTPUT");
                const status = C.luaL_dofile(state.L, "main.lua");
                if (status !== 0) {
                  const err = C.lua_tostring(state.L, -1);
                  resetLuaBeautifier();
                  reject(new Error(err || "Failed to initialize FormatLua"));
                  return;
                }
                luaBeautifier.state = state;
                resolve(state);
              } catch (error) {
                resetLuaBeautifier();
                reject(error);
              }
            });

            return luaBeautifier.initPromise;
          }

          async function formatLuaWithFormatLua(source) {
            const state = await initLuaBeautifier();
            const { C, L } = state;
            state.output = "";
            C.lua_pushstring(L, source);
            C.lua_setglobal(L, "toS");
            const status = C.luaL_dostring(
              L,
              "OUTPUT(M.indentcode(toS, [[\\n]], true, '    '))"
            );
            if (status !== 0) {
              const err = C.lua_tostring(L, -1);
              resetLuaBeautifier();
              throw new Error(err || "FormatLua error");
            }
            return state.output || source;
          }

        const homeSections = [];
        let currentHomeSection = null;

        function AddHeader(title) {
            const section = {
                title: title || "Home",
                links: [],
                open: true
            };
            homeSections.push(section);
            currentHomeSection = section;
            return section;
        }

        function AddLink(title, icon, link) {
            if (!currentHomeSection) {
                AddHeader("");
            }

            currentHomeSection.links.push({
                title,
                icon: icon || "",
                link
            });

            return currentHomeSection;
        }

        function renderHome() {
            const list = q("#home_sections");
            if (!list) {
                return;
            }

            list.innerHTML = "";
            const fragment = document.createDocumentFragment();

            for (const section of homeSections) {
                const block = document.createElement("div");
                block.className = "g home-section";

                const headerWrap = document.createElement("div");
                headerWrap.className = "home-section__header";

                const header = document.createElement("h3");
                header.textContent = section.title;

                const toggle = document.createElement("button");
                toggle.type = "button";
                toggle.className = "home-section__toggle";
                toggle.setAttribute(
                    "aria-expanded",
                    section.open ? "true" : "false"
                );
                toggle.innerHTML = section.open ? "▲" : "▼";

                headerWrap.append(header, toggle);

                const content = document.createElement("div");
                content.className = "gr home-section__content";
                if (!section.open) {
                    content.classList.add("home-section__content--collapsed");
                }

                for (const item of section.links) {
                    const tile = document.createElement("a");
                    tile.className = "tl";
                    tile.href = item.link;
                    tile.rel = "noopener";
                    tile.target = "_blank";
                    tile.dataset.h = host(item.link);

                    const parts = [];
                    if (item.icon) {
                        parts.push(`<img alt="" src="${item.icon}">`);
                    }
                    parts.push(`<span>${item.title}</span>`);
                    tile.innerHTML = parts.join("");
                    content.appendChild(tile);
                }

                toggle.addEventListener("click", () => {
                    section.open = !section.open;
                    content.classList.toggle(
                        "home-section__content--collapsed",
                        !section.open
                    );
                    toggle.setAttribute(
                        "aria-expanded",
                        section.open ? "true" : "false"
                    );
                    toggle.innerHTML = section.open ? "▲" : "▼";
                });

                block.append(headerWrap, content);
                fragment.appendChild(block);
            }

            list.appendChild(fragment);
        }

        window.AddHeader = AddHeader;
        window.AddLink = AddLink;

        const builderIconsSection = q("#pb");
        const builderIconsFullScreenButton = q("#bi-fullscreen-toggle");
        let builderIconsFullscreen = false;

        AddHeader("Socials");
        AddLink(
            "Scriptblox",
            "https://r2.guns.lol/7e671c9b-1689-4d72-a5e5-b972f7d7fb09.png",
            "https://scriptblox.com/u/Vyperia"
        );
        AddLink(
            "rscripts",
            "https://r2.guns.lol/b9234319-f7c7-4b19-840e-600a2044d401.png",
            "https://rscripts.net/@ltseverydayyou"
        );
        AddLink(
            "Discord Profile",
            "https://cdn.simpleicons.org/discord",
            "https://discord.com/users/641335879381680129"
        );
        AddLink(
            "guns.lol",
            "https://assets.guns.lol/guns_logo_no_background_cropped.png",
            "https://guns.lol/ltseverydayyou"
        );
        AddLink(
            "GitHub",
            "https://cdn.simpleicons.org/github",
            "https://github.com/ltseverydayyou"
        );
        AddLink(
            "Spotify",
            "https://cdn.simpleicons.org/spotify",
            "https://open.spotify.com/user/316a6txgaro3ethw6pochw3uripy"
        );
        AddLink(
            "Steam",
            "https://cdn.simpleicons.org/steam",
            "https://steamcommunity.com/id/ltseverydayyou"
        );

        AddHeader("Roblox");
        AddLink(
            "Vyperia_X",
            "https://cdn.simpleicons.org/roblox",
            "https://www.roblox.com/users/11761417/profile"
        );
        AddLink(
            "Aervanix",
            "https://cdn.simpleicons.org/roblox",
            "https://www.roblox.com/users/2502806181/profile"
        );
        AddLink(
            "Jadiellovescats3",
            "https://cdn.simpleicons.org/roblox",
            "https://www.roblox.com/users/2845101018/profile"
        );

        AddHeader("Roblox Group(s)");
        AddLink(
            "Dreadborne",
            "https://tr.rbxcdn.com/180DAY-3598f5067f011a7e3b2ae3e0f08ca401/150/150/Image/Webp/noFilter",
            "https://www.roblox.com/communities/36041342/Dreadborne-DEV-TEAM#!/about"
        );
        AddLink(
            "Quantum Makers Syndicate",
            "https://tr.rbxcdn.com/180DAY-1f41d6d797e7664b6825c228bcf84c1a/150/150/Image/Webp/noFilter",
            "https://www.roblox.com/communities/34232955/Quantum-Makers-Syndicate#!/about"
        );
        AddLink(
            "Tide escape official Group",
            "https://tr.rbxcdn.com/180DAY-cbc891e8671884f135dc7d7c63ab259e/150/150/Image/Webp/noFilter",
            "https://www.roblox.com/communities/11152575/Tide-escape-official-Group#!/about"
        );

        const scriptItems = [];

        const scriptSearcherState = {
            query: "",
            rscripts: {
                page: 1,
                maxPages: 1
            },
            scriptblox: {
                page: 1,
                maxPages: 1
            }
        };

        const scriptSearchPanels = {
            rscripts: {
                container: q("#script-search-rscripts"),
                meta: q("#script-search-rscripts-meta"),
                error: q("#script-search-rscripts-error"),
                label: "Rscripts",
                pageLabel: q("#script-search-rscripts-page"),
                prev: q("#script-search-rscripts-prev"),
                next: q("#script-search-rscripts-next")
            },
            scriptblox: {
                container: q("#script-search-scriptblox"),
                meta: q("#script-search-scriptblox-meta"),
                error: q("#script-search-scriptblox-error"),
                label: "ScriptBlox",
                pageLabel: q("#script-search-scriptblox-page"),
                prev: q("#script-search-scriptblox-prev"),
                next: q("#script-search-scriptblox-next")
            }
        };
        const MAX_SCRIPT_RESULTS = 8;

        function updatePanelControls(panelKey) {
            const panel = scriptSearchPanels[panelKey];
            if (!panel || !panel.container) {
                return;
            }
            const pagination = scriptSearcherState[panelKey] || {
                page: 1,
                maxPages: 1
            };
            if (panel.pageLabel) {
                panel.pageLabel.textContent =
                    pagination.maxPages && pagination.maxPages > 1 ?
                    `Page ${pagination.page} / ${pagination.maxPages}` :
                    `Page ${pagination.page}`;
            }
            if (panel.prev) {
                panel.prev.disabled = pagination.page <= 1 || panel.isLoading;
            }
            if (panel.next) {
                const hasLimit = pagination.maxPages && pagination.maxPages > 0;
                panel.next.disabled =
                    (hasLimit ? pagination.page >= pagination.maxPages : false) ||
                    panel.isLoading;
            }
        }

        function formatScriptDate(value) {
            if (!value) {
                return "Unknown date";
            }
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return "Unknown date";
            }
            return date.toLocaleDateString(undefined, {
                month: "short",
                day: "numeric",
                year: "numeric"
            });
        }

        function resolveScriptImage(entry, source) {
            const candidates = [
                entry.image,
                entry.game?.imgurl,
                entry.game?.imageUrl,
                entry.game?.gameLogo
            ];
            const picked = candidates.find((url) => typeof url === "string" && url.trim());
            if (!picked) {
                return "";
            }
            if (picked.startsWith("http")) {
                return picked;
            }
            if (picked.startsWith("//")) {
                return `https:${picked}`;
            }
            if (source === "ScriptBlox") {
                return `https://scriptblox.com${picked.startsWith("/") ? "" : "/"}${picked}`;
            }
            return picked;
        }

        function getPanelPageSummary(panelKey, count) {
            const pagination = scriptSearcherState[panelKey] || {
                page: 1,
                maxPages: 1
            };
            const parts = [
                `${count} script${count === 1 ? "" : "s"}`,
                pagination.maxPages && pagination.maxPages > 1 ?
                `Page ${pagination.page} / ${pagination.maxPages}` :
                `Page ${pagination.page}`
            ];
            return parts.join(" - ");
        }

        function getRobloxGameLink(entry) {
            const placeId =
                entry.game?.placeId ||
                entry.game?.gameId ||
                entry.placeId ||
                entry.gameId;
            if (!placeId) {
                return null;
            }
            return `https://www.roblox.com/games/${placeId}`;
        }

        function getScriptMetadata(entry, source) {
            const rawLikes = entry.likes ?? entry.likeCount;
            const rawDislikes = entry.dislikes ?? entry.dislikeCount;
            const likes = typeof rawLikes === "number" ? rawLikes : null;
            const dislikes = typeof rawDislikes === "number" ? rawDislikes : null;
            const ratio =
                (likes ?? 0) + (dislikes ?? 0) > 0 ?
                Math.round(((likes ?? 0) / ((likes ?? 0) + (dislikes ?? 0))) * 100) :
                null;
            const keyRequired = entry.keySystem ?? entry.key ?? false;
            const scriptType = entry.scriptType || "";
            const universal = Boolean(entry.isUniversal);
            const patched = Boolean(entry.isPatched);
            const verified =
                entry.user?.verified ??
                entry.verified ??
                false;
            const author =
                entry.user?.username ||
                entry.author ||
                entry.creator ||
                entry.owner?.username ||
                entry.ownerName ||
                entry.createdBy?.name ||
                (source === "ScriptBlox" ? "ScriptBlox user" : "Unknown");
            const updated =
                entry.lastUpdated || entry.last_updated || entry.lastBump || entry.updatedAt;
            const created = entry.createdAt || entry.created_at;
            const createdLabel = created ? formatScriptDate(created) : "";
            const updatedLabel = updated ? formatScriptDate(updated) : "";
            const timelineLabel =
                source === "ScriptBlox" ?
                createdLabel ?
                `Posted ${createdLabel}` :
                updatedLabel ?
                `Updated ${updatedLabel}` :
                "" :
                updatedLabel ?
                `Updated ${updatedLabel}` :
                createdLabel ?
                `Posted ${createdLabel}` :
                "";
            const gameName = entry.game?.title || entry.game?.name || "";
            const gameLink =
                entry.game?.gameLink ||
                entry.gameLink ||
                getRobloxGameLink(entry);
            const pills = [];
            if (verified) {
                pills.push("Verified");
            }
            if (keyRequired) {
                pills.push("Key required");
            }
            if (scriptType) {
                pills.push(scriptType);
            }
            if (universal) {
                pills.push("Universal");
            }
            if (patched) {
                pills.push("Patched");
            }
            return {
                author,
                timelineLabel,
                gameName,
                likes,
                dislikes,
                ratio,
                gameLink,
                pills,
                createdLabel,
                updatedLabel
            };
        }

        function createScriptCard(entry, source) {
            const title = (entry.title || entry.name || "Untitled").trim();
            const card = document.createElement("article");
            card.className = "script-card";

            const metaInfo = getScriptMetadata(entry, source);
            const imageUrl = resolveScriptImage(entry, source);
            if (imageUrl) {
                const thumb = document.createElement("img");
                thumb.className = "script-card__thumb";
                thumb.src = imageUrl;
                thumb.alt = "";
                card.appendChild(thumb);
            }

            const titleLink = document.createElement("a");
            titleLink.className = "script-card__title";
            titleLink.textContent = title;

            const customUrl =
                entry.url ||
                entry.link ||
                (source === "Rscripts" && entry.slug ?
                    `https://rscripts.net/script/${entry.slug}` :
                    null) ||
                (source === "ScriptBlox" && entry.slug ?
                    `https://scriptblox.com/script/${entry.slug}` :
                    null);
            if (customUrl) {
                titleLink.href = customUrl;
                titleLink.target = "_blank";
                titleLink.rel = "noopener noreferrer";
            } else {
                titleLink.href = "#";
                titleLink.addEventListener("click", (event) => event.preventDefault());
            }

            const meta = document.createElement("div");
            meta.className = "script-card__meta";
            const metaParts = [];
            if (metaInfo.author) {
                metaParts.push(`By ${metaInfo.author}`);
            }
            if (metaInfo.gameName) {
                metaParts.push(metaInfo.gameName);
            }
            if (metaInfo.timelineLabel) {
                metaParts.push(metaInfo.timelineLabel);
            }
            meta.textContent = metaParts.length ?
                metaParts.join(" | ") :
                "Metadata unavailable";

            const description = document.createElement("p");
            description.className = "script-card__description";
            const rawDescription = (entry.description || entry.summary || "").trim();
            const trimmed =
                rawDescription.length > 150 ?
                `${rawDescription.slice(0, 150).trim()}...` :
                rawDescription;
            description.textContent = trimmed || "No description provided.";

            const layout = [titleLink, meta, description];

            const details = document.createElement("dl");
            details.className = "script-card__details";
            let detailCount = 0;
            const addDetail = (label, value, options) => {
                if (!value) {
                    return;
                }
                const dt = document.createElement("dt");
                dt.textContent = label;
                const dd = document.createElement("dd");
                if (options && options.href) {
                    const link = document.createElement("a");
                    link.href = options.href;
                    link.target = "_blank";
                    link.rel = "noopener noreferrer";
                    link.textContent = value;
                    dd.appendChild(link);
                } else {
                    dd.textContent = value;
                }
                details.append(dt, dd);
                detailCount += 1;
            };

            addDetail("Author", metaInfo.author);
            if (metaInfo.gameName) {
                addDetail(
                    "Game",
                    metaInfo.gameName,
                    metaInfo.gameLink ? {
                        href: metaInfo.gameLink
                    } : null
                );
            }
            if (metaInfo.createdLabel) {
                addDetail("Posted", metaInfo.createdLabel);
            }
            if (
                metaInfo.updatedLabel &&
                metaInfo.updatedLabel !== metaInfo.createdLabel
            ) {
                addDetail("Updated", metaInfo.updatedLabel);
            }
            if (detailCount) {
                layout.push(details);
            }

            const statsParts = [];
            if (typeof metaInfo.likes === "number") {
                statsParts.push(`Likes ${metaInfo.likes.toLocaleString()}`);
            }
            if (typeof metaInfo.dislikes === "number") {
                statsParts.push(`Dislikes ${metaInfo.dislikes.toLocaleString()}`);
            }
            if (metaInfo.ratio !== null && metaInfo.ratio !== undefined) {
                statsParts.push(`Approval ${metaInfo.ratio}%`);
            }
            if (statsParts.length) {
                const statsRow = document.createElement("div");
                statsRow.className = "script-card__stats";
                statsRow.textContent = statsParts.join(" | ");
                layout.push(statsRow);
            }

            if (metaInfo.pills.length) {
                const pillsRow = document.createElement("div");
                pillsRow.className = "script-card__pills";
                metaInfo.pills.forEach((text) => {
                    const pill = document.createElement("span");
                    pill.className = "script-card__pill";
                    pill.textContent = text;
                    pillsRow.appendChild(pill);
                });
                layout.push(pillsRow);
            }

            const buttonRow = document.createElement("div");
            buttonRow.className = "script-card__buttons";
            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.className = "script-card__button";
            copyBtn.textContent = "Copy code";
            copyBtn.addEventListener("click", () => {
                copyScriptCode(entry, source);
            });
            buttonRow.appendChild(copyBtn);

            if (source === "Rscripts" && entry.discord) {
                const discordBtn = document.createElement("a");
                discordBtn.className = "script-card__button";
                discordBtn.textContent = "Open Discord";
                discordBtn.href = entry.discord;
                discordBtn.target = "_blank";
                discordBtn.rel = "noopener noreferrer";
                buttonRow.appendChild(discordBtn);
            }

            if (metaInfo.gameLink) {
                const gameBtn = document.createElement("a");
                gameBtn.className = "script-card__button";
                gameBtn.textContent = "Open game";
                gameBtn.href = metaInfo.gameLink;
                gameBtn.target = "_blank";
                gameBtn.rel = "noopener noreferrer";
                buttonRow.appendChild(gameBtn);
            }

            const footer = document.createElement("div");
            footer.className = "script-card__footer";
            const viewsText =
                entry.views ?? entry.viewCount ?? entry.totalViews ?? 0;
            const viewsEl = document.createElement("span");
            viewsEl.textContent = viewsText ?
                `${Number(viewsText).toLocaleString()} views` :
                "Views unknown";

            const actionLink = document.createElement("a");
            actionLink.className = "script-card__link";
            actionLink.textContent = `Open on ${source}`;
            if (customUrl) {
                actionLink.href = customUrl;
                actionLink.target = "_blank";
                actionLink.rel = "noopener noreferrer";
            } else {
                actionLink.setAttribute("aria-disabled", "true");
                actionLink.href = "#";
            }

            footer.append(viewsEl, actionLink);
            if (buttonRow.children.length) {
                layout.push(buttonRow);
            }

            layout.push(footer);
            card.append(...layout);
            return card;
        }

        function renderPanelMessage(panel, text) {
            if (!panel?.container) {
                return;
            }
            panel.container.innerHTML = "";
            const messageEl = document.createElement("div");
            messageEl.className = "script-searcher__empty";
            messageEl.textContent = text;
            panel.container.appendChild(messageEl);
        }

        function setPanelError(panel, text) {
            if (!panel?.error) {
                return;
            }
            panel.error.textContent = text || "";
            if (text && panel.container) {
                panel.container.innerHTML = "";
                setPanelMeta(panel, "");
            }
        }

        function setPanelMeta(panel, text) {
            if (!panel?.meta) {
                return;
            }
            panel.meta.textContent = text || "";
        }

        function renderSearchPanel(panelKey, scripts) {
            const panel = scriptSearchPanels[panelKey];
            if (!panel?.container) {
                return;
            }
            panel.container.innerHTML = "";
            if (!Array.isArray(scripts) || !scripts.length) {
                setPanelMeta(panel, "No results");
                renderPanelMessage(panel, "No scripts matched that query.");
                return;
            }
            setPanelMeta(panel, getPanelPageSummary(panelKey, scripts.length));
            scripts.slice(0, MAX_SCRIPT_RESULTS).forEach((entry) => {
                panel.container.appendChild(createScriptCard(entry, panel.label));
            });
        }

        function parsePanelPayload(panelKey, payload) {
            if (panelKey === "rscripts") {
                const info = payload?.info || {};
                return {
                    scripts: Array.isArray(payload?.scripts) ? payload.scripts : [],
                    maxPages: Math.max(info.maxPages || 1, 1)
                };
            }
            const result = payload?.result || {};
            return {
                scripts: Array.isArray(result.scripts) ? result.scripts : [],
                maxPages: Math.max(result.totalPages || 1, 1)
            };
        }

        async function fetchRscripts(query = "", page = 1) {
            const url = new URL("https://rscripts.net/api/v2/scripts");
            url.searchParams.set("page", page.toString());
            url.searchParams.set("orderBy", "date");
            url.searchParams.set("sort", "desc");
            if (query) {
                url.searchParams.set("q", query);
            }
            const response = await fetch(url.toString(), {
                mode: "cors"
            });
            if (!response.ok) {
                throw new Error("Rscripts API error");
            }
            return response.json();
        }

        async function fetchScriptblox(query = "", page = 1) {
            const endpoint = query ?
                "https://scriptblox.com/api/script/search" :
                "https://scriptblox.com/api/script/fetch";
            const url = new URL(endpoint);
            if (query) {
                url.searchParams.set("q", query);
            }
            url.searchParams.set("page", page.toString());
            const response = await fetch(url.toString(), {
                mode: "cors"
            });
            if (!response.ok) {
                throw new Error("ScriptBlox API error");
            }
            return response.json();
        }

        async function copyScriptCode(entry, source) {
            let scriptBody = entry.script;
            if (!scriptBody && entry.rawScript) {
                try {
                    const resp = await fetch(entry.rawScript, {
                        mode: "cors"
                    });
                    if (!resp.ok) {
                        throw new Error("Failed to fetch script");
                    }
                    scriptBody = await resp.text();
                } catch (error) {
                    console.error(error);
                    toast("Unable to fetch script content");
                    return;
                }
            }
            if (!scriptBody) {
                toast("Script content unavailable");
                return;
            }
            try {
                await navigator.clipboard.writeText(scriptBody);
                toast("Script copied");
            } catch (error) {
                console.error(error);
                toast("Clipboard permissions denied");
            }
        }

        async function loadPanel(panelKey) {
            const panel = scriptSearchPanels[panelKey];
            if (!panel || !panel.container || panel.isLoading) {
                return;
            }
            panel.isLoading = true;
            updatePanelControls(panelKey);
            setPanelError(panel, "");
            setPanelMeta(panel, "");
            renderPanelMessage(panel, "Loading results...");
            try {
                const pagination = scriptSearcherState[panelKey];
                const page = pagination?.page || 1;
                const payload =
                    panelKey === "rscripts" ?
                    await fetchRscripts(scriptSearcherState.query, page) :
                    await fetchScriptblox(scriptSearcherState.query, page);
                const parsed = parsePanelPayload(panelKey, payload);
                scriptSearcherState[panelKey].maxPages = parsed.maxPages || 1;
                updatePanelControls(panelKey);
                renderSearchPanel(panelKey, parsed.scripts);
            } catch (error) {
                console.error(error);
                const friendlyMessage =
                    panelKey === "scriptblox" ?
                    "ScriptBlox data requires direct API access. Try again shortly." :
                    "Unable to load scripts.";
                setPanelError(panel, friendlyMessage);
                renderPanelMessage(panel, "Results could not be loaded.");
            } finally {
                panel.isLoading = false;
                updatePanelControls(panelKey);
            }
        }

        function changePanelPage(panelKey, delta) {
            const panel = scriptSearchPanels[panelKey];
            if (!panel?.container) {
                return;
            }
            const pagination = scriptSearcherState[panelKey];
            if (!pagination) {
                return;
            }
            const newPage = pagination.page + delta;
            if (newPage < 1) {
                return;
            }
            if (pagination.maxPages && pagination.maxPages > 0 && newPage > pagination.maxPages) {
                return;
            }
            pagination.page = newPage;
            updatePanelControls(panelKey);
            loadPanel(panelKey);
        }

        async function performScriptSearch(term, button) {
            scriptSearcherState.query = (term || "").trim();
            scriptSearcherState.rscripts.page = 1;
            scriptSearcherState.rscripts.maxPages = 1;
            scriptSearcherState.scriptblox.page = 1;
            scriptSearcherState.scriptblox.maxPages = 1;
            updatePanelControls("rscripts");
            updatePanelControls("scriptblox");
            if (button) {
                button.disabled = true;
                button.textContent = "Searching...";
            }
            try {
                await Promise.allSettled([loadPanel("rscripts"), loadPanel("scriptblox")]);
            } finally {
                if (button) {
                    button.disabled = false;
                    button.textContent = "Search";
                }
            }
        }

        function initScriptSearcher() {
            const root = q("#script-searcher");
            if (!root) {
                return;
            }
            const input = root.querySelector("#script-search-query");
            const button = root.querySelector("#script-search-btn");
            if (!input || !button) {
                return;
            }

            Object.entries(scriptSearchPanels).forEach(([key, panel]) => {
                if (panel.prev) {
                    panel.prev.addEventListener("click", () => changePanelPage(key, -1));
                }
                if (panel.next) {
                    panel.next.addEventListener("click", () => changePanelPage(key, 1));
                }
                updatePanelControls(key);
            });

            const runSearch = () => performScriptSearch(input.value, button);
            button.addEventListener("click", runSearch);
            input.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    runSearch();
                }
            });

            performScriptSearch("", null);
        }

        const versionBaseUrl = "https://weao.gg/api/versions";
        const versionSpecs = [{
                type: "current",
                title: "Current (Live)",
                description: "Latest builds for Windows, Mac, Android, and iOS.",
                endpoint: "current",
                fields: [{
                        key: "Windows",
                        label: "Windows"
                    },
                    {
                        key: "WindowsDate",
                        label: "Windows date"
                    },
                    {
                        key: "Android",
                        label: "Android"
                    },
                    {
                        key: "AndroidDate",
                        label: "Android date"
                    },
                    {
                        key: "iOS",
                        label: "iOS"
                    },
                    {
                        key: "iOSDate",
                        label: "iOS date"
                    },
                    {
                        key: "Mac",
                        label: "Mac"
                    },
                    {
                        key: "MacDate",
                        label: "Mac date"
                    }
                ]
            },
            {
                type: "future",
                title: "Future (Live)",
                description: "Next builds that the live channel is tracking.",
                endpoint: "future",
                fields: [{
                        key: "Windows",
                        label: "Windows"
                    },
                    {
                        key: "WindowsDate",
                        label: "Windows date"
                    },
                    {
                        key: "Mac",
                        label: "Mac"
                    },
                    {
                        key: "MacDate",
                        label: "Mac date"
                    }
                ]
            },
            {
                type: "past",
                title: "Past (Live)",
                description: "Previous deployments that can still be referenced.",
                endpoint: "past",
                fields: [{
                        key: "Windows",
                        label: "Windows"
                    },
                    {
                        key: "WindowsDate",
                        label: "Windows date"
                    },
                    {
                        key: "Mac",
                        label: "Mac"
                    },
                    {
                        key: "MacDate",
                        label: "Mac date"
                    }
                ]
            }
        ];
        const versionElements = new Map();

        function initVersionCards() {
            const grid = q("#versions-grid");
            if (!grid) {
                return;
            }

            versionElements.clear();
            grid.innerHTML = "";

            for (const spec of versionSpecs) {
                const card = document.createElement("article");
                card.className = "version-card";

                const header = document.createElement("div");
                header.className = "version-card__head";

                const textStack = document.createElement("div");
                const title = document.createElement("p");
                title.className = "version-card__title";
                title.textContent = spec.title;
                const desc = document.createElement("p");
                desc.className = "version-card__desc";
                desc.textContent = spec.description;
                textStack.append(title, desc);

                const refresh = document.createElement("button");
                refresh.type = "button";
                refresh.className = "version-card__refresh";
                refresh.textContent = "Refresh";
                refresh.addEventListener("click", () => fetchVersionData(spec));

                header.append(textStack, refresh);

                const body = document.createElement("div");
                body.className = "version-card__body";
                body.innerHTML = '<p class="version-card__placeholder">Loading...</p>';

                const status = document.createElement("div");
                status.className = "version-card__status";
                status.textContent = "Waiting for data...";

                card.append(header, body, status);
                grid.appendChild(card);

                versionElements.set(spec.type, {
                    body,
                    status
                });
            }
        }

        function renderVersionData(container, data, fields) {
            const dl = document.createElement("dl");

            for (const field of fields) {
                const dt = document.createElement("dt");
                dt.textContent = field.label;
                const dd = document.createElement("dd");
                const value =
                    data && Object.prototype.hasOwnProperty.call(data, field.key) ?
                    data[field.key] :
                    null;
                dd.textContent = value ?? "N/A";
                dl.append(dt, dd);
            }

            container.innerHTML = "";
            container.appendChild(dl);
        }

        async function fetchVersionData(spec) {
            const elements = versionElements.get(spec.type);
            if (!elements) {
                return;
            }

            const {
                body,
                status
            } = elements;
            status.textContent = "Fetching data...";
            body.innerHTML = '<p class="version-card__placeholder">Loading...</p>';

            try {
                const res = await fetch(`${versionBaseUrl}/${spec.endpoint}`);
                if (!res.ok) {
                    throw new Error(`${res.status} ${res.statusText || "Error"}`);
                }

                const payload = await res.json();
                renderVersionData(body, payload, spec.fields);
                const timestamp = new Date().toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                });
                status.textContent = `Updated ${timestamp}`;
            } catch (error) {
                body.innerHTML = `<p class="version-card__error">Unable to load data: ${error.message}</p>`;
                status.textContent = "Failed to load";
            }
        }

        const executorEndpoint = "https://weao.gg/api/status/exploits";
        const executorPlatformOrder = ["Windows", "Android", "iOS", "Mac"];
        const platformFilters = {
            all: () => true,
            windows: (platform) => (platform || "").toLowerCase() === "windows",
            mac: (platform) => (platform || "").toLowerCase() === "mac",
            android: (platform) => (platform || "").toLowerCase() === "android",
            ios: (platform) => (platform || "").toLowerCase() === "ios"
        };
        let executorFilter = "all";
        let executorCache = [];

        function updateHeroStats(overrides = {}) {
            const scriptCount =
                typeof overrides.scriptCount === "number" ?
                overrides.scriptCount :
                scriptItems.length;
            const executorCount =
                typeof overrides.executorCount === "number" ?
                overrides.executorCount :
                Array.isArray(executorCache) ?
                executorCache.length :
                0;
            const socialCount =
                typeof overrides.socialCount === "number" ?
                overrides.socialCount :
                homeSections.reduce(
                    (total, section) =>
                    total + (Array.isArray(section.links) ? section.links.length : 0),
                    0
                );

            const setStat = (selector, value) => {
                const node = q(selector);
                if (node && typeof value === "number") {
                    node.textContent = value.toString();
                }
            };

            setStat("#hero-script-count", scriptCount);
            setStat("#hero-executor-count", executorCount);
            setStat("#hero-link-count", socialCount);
        }

        const isExternalExecutor = (entry) => {
            return (entry?.extype || "").toLowerCase().includes("external");
        };

        function getPlatformRank(platform) {
            if (!platform) {
                return executorPlatformOrder.length;
            }
            const normalized = (platform || "").toLowerCase();
            const index = executorPlatformOrder.findIndex(
                (item) => item.toLowerCase() === normalized
            );
            return index === -1 ? executorPlatformOrder.length : index;
        }

        function formatPercent(value) {
            if (value === 0) {
                return "0%";
            }
            if (typeof value === "number") {
                return `${value}%`;
            }
            if (typeof value === "string" && value.trim()) {
                return `${value}%`;
            }
            return "-";
        }

        function createExecutorCard(executor) {
            const card = document.createElement("article");
            card.className = "executor-card";

            const title = document.createElement("p");
            title.className = "executor-card__title";
            title.textContent = executor.title;

            const meta = document.createElement("div");
            meta.className = "executor-card__meta";

            const infoStack = document.createElement("div");
            infoStack.className = "executor-card__meta-info";

            const type = document.createElement("span");
            type.className = "executor-card__type";
            type.textContent = executor.platform || "Unknown";

            const statusPill = document.createElement("span");
            statusPill.className = `executor-card__status-pill${
              executor.updateStatus ? "" : " executor-card__status-pill--down"
            }`;
            statusPill.textContent = executor.updateStatus ? "Up" : "Down";

            infoStack.append(type, statusPill);
            meta.append(title, infoStack);

            const pills = document.createElement("div");
            pills.className = "executor-card__pills";

            const addPill = (text, variant) => {
                if (!text) {
                    return;
                }
                const pill = document.createElement("span");
                pill.className = `executor-card__pill${
                variant ? ` executor-card__pill--${variant}` : ""
              }`;
                pill.textContent = text;
                pills.appendChild(pill);
            };

            const categoryText = isExternalExecutor(executor) ? "External" : "Internal";
            addPill(categoryText, categoryText === "External" ? "info" : "good");
            addPill(executor.uncStatus ? "UNC" : "No UNC", executor.uncStatus ? "good" : "warn");
            addPill(executor.detected ? "Detected" : "Undetected", executor.detected ? "warn" : "good");
            addPill(executor.free ? "Free" : "Paid", executor.free ? "good" : "info");
            addPill(executor.beta ? "Beta" : "Stable", executor.beta ? "info" : "good");

            const body = document.createElement("div");
            body.className = "executor-card__body";
            const fields = [{
                    label: "Type",
                    value: executor.extype
                },
                {
                    label: "Version",
                    value: executor.version
                },
                {
                    label: "RBX version",
                    value: executor.rbxversion
                },
                {
                    label: "sUNC",
                    value: formatPercent(executor.suncPercentage)
                },
                {
                    label: "UNC",
                    value: formatPercent(executor.uncPercentage)
                },
                {
                    label: "Last updated",
                    value: executor.updatedDate
                }
            ];

            for (const field of fields) {
                const dt = document.createElement("dt");
                dt.textContent = field.label;
                const dd = document.createElement("dd");
                dd.textContent = field.value ?? "-";
                body.append(dt, dd);
            }

            const links = document.createElement("div");
            links.className = "executor-card__links";
            if (executor.websitelink) {
                const siteLink = document.createElement("a");
                siteLink.href = executor.websitelink;
                siteLink.target = "_blank";
                siteLink.rel = "noopener noreferrer";
                siteLink.textContent = "Website";
                links.appendChild(siteLink);
            }
            if (executor.discordlink) {
                const discordLink = document.createElement("a");
                discordLink.href = executor.discordlink;
                discordLink.target = "_blank";
                discordLink.rel = "noopener noreferrer";
                discordLink.textContent = "Discord";
                links.appendChild(discordLink);
            }

            card.append(meta, pills, body);
            if (links.childElementCount) {
                card.appendChild(links);
            }

            return card;
        }

        function renderExecutorCards() {
            const grid = q("#executor-grid");
            if (!grid) {
                return;
            }

            const entries = executorCache.filter((entry) => entry && entry.title);
            if (!entries.length) {
                grid.innerHTML =
                    '<p class="executor-card__placeholder">No executor data available.</p>';
                return;
            }

            const sorted = entries
                .slice()
                .sort((a, b) => {
                    const aIsExternal = isExternalExecutor(a);
                    const bIsExternal = isExternalExecutor(b);
                    const typeRank = Number(!aIsExternal) - Number(!bIsExternal);
                    if (typeRank !== 0) {
                        return typeRank;
                    }

                    const rankDiff = getPlatformRank(a.platform) - getPlatformRank(b.platform);
                    if (rankDiff !== 0) {
                        return rankDiff;
                    }

                    return (a.title || "").localeCompare(b.title || "");
                })
                .filter((entry) => platformFilters[executorFilter](entry.platform));

            if (!sorted.length) {
                grid.innerHTML =
                    '<p class="executor-card__placeholder">No executor data available.</p>';
                return;
            }

            grid.innerHTML = "";
            const fragment = document.createDocumentFragment();

            if (executorFilter === "windows") {
                const internals = sorted.filter((entry) => !isExternalExecutor(entry));
                const externals = sorted.filter(isExternalExecutor);
                internals.forEach((executor) => fragment.appendChild(createExecutorCard(executor)));
                if (externals.length) {
                    const divider = document.createElement("div");
                    divider.className = "executor-divider";
                    divider.textContent = "External";
                    fragment.appendChild(divider);
                    externals.forEach((executor) => fragment.appendChild(createExecutorCard(executor)));
                }
            } else {
                sorted.forEach((executor) => fragment.appendChild(createExecutorCard(executor)));
            }

            grid.appendChild(fragment);
        }

        function setExecutorFilter(filter) {
            executorFilter = platformFilters[filter] ? filter : "all";
            qa(".executor-tab").forEach((tab) => {
                tab.classList.toggle(
                    "executor-tab--active",
                    tab.dataset.filter === executorFilter
                );
            });
            renderExecutorCards();
        }

        async function loadExecutorStatuses() {
            const grid = q("#executor-grid");
            const status = q("#executor-status");
            if (!grid || !status) {
                return;
            }

            status.textContent = "Fetching executor statuses...";
            grid.innerHTML = '<p class="executor-card__placeholder">Loading...</p>';

            try {
                const res = await fetch(executorEndpoint);
                if (!res.ok) {
                    throw new Error(`${res.status} ${res.statusText || "Error"}`);
                }
                const payload = await res.json();
                executorCache = Array.isArray(payload) ? payload : [];
                renderExecutorCards();
                updateHeroStats({
                    executorCount: executorCache.length
                });
                const timestamp = new Date().toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                });
                status.textContent = `Updated ${timestamp}`;
            } catch (error) {
                grid.innerHTML = `<p class="version-card__error">Unable to load executor data: ${error.message}</p>`;
                status.textContent = "Failed to load";
            }
        }

        function renderScripts() {
            const list = q("#sc_list");
            if (!list) {
                return;
            }

            list.innerHTML = "";
            const featuredList = scriptItems.filter((item) => item.featured);
            const regularList = scriptItems.filter((item) => !item.featured);
            const sorted = [...featuredList, ...regularList];
            const fragment = document.createDocumentFragment();

            for (const item of sorted) {
                const entry = document.createElement("div");
                entry.className = "sc";
                if (item.featured) {
                    entry.classList.add("featured");
                }
                entry.dataset.u = item.url;

                const info = document.createElement("div");
                info.className = "sc_info";

                if (item.image) {
                    const img = document.createElement("img");
                    img.className = "sc_img";
                    img.src = item.image;
                    img.alt = item.name;
                    info.appendChild(img);
                }

                const text = document.createElement("div");
                text.className = "sc_text";

                const title = document.createElement("span");
                title.className = "nm";
                title.textContent = item.name;
                text.appendChild(title);

                if (item.featured) {
                    const badge = document.createElement("span");
                    badge.className = "sc_badge";
                    badge.textContent = "Featured";
                    text.appendChild(badge);
                }

                info.appendChild(text);

                const controls = document.createElement("div");
                controls.className = "brw";

                const copyBtn = document.createElement("button");
                copyBtn.className = "bn cp";
                copyBtn.dataset.a = "c";
                copyBtn.type = "button";
                copyBtn.textContent = "Copy";

                const viewBtn = document.createElement("button");
                viewBtn.className = "bn vw";
                viewBtn.dataset.a = "v";
                viewBtn.type = "button";
                viewBtn.textContent = "View";

                controls.append(copyBtn, viewBtn);

                if (item.game) {
                    const gameBtn = document.createElement("button");
                    gameBtn.className = "bn gm";
                    gameBtn.dataset.game = item.game;
                    gameBtn.type = "button";
                    gameBtn.textContent = "Play";
                    controls.append(gameBtn);
                }

                entry.append(info, controls);
                fragment.appendChild(entry);
            }

            list.appendChild(fragment);
            updateHeroStats();
        }

        function ScriptAdd(name, url, imageUrl, featured = false, gameLink = "") {
            const flag =
                typeof featured === "string" ?
                featured.toLowerCase() === "true" :
                Boolean(featured);

            scriptItems.push({
                name,
                url,
                image: imageUrl || "",
                featured: flag,
                game: gameLink || ""
            });

            renderScripts();
        }

        window.ScriptAdd = ScriptAdd;

        ScriptAdd(
            "NA Main Version",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/Source.lua",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAimages/NAnew.png",
            true
        );
        ScriptAdd(
            "NA Testing Version",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/main/NA%20testing.lua",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAimages/NAnew.png"
        );
        ScriptAdd(
            "FNB Autoplayer",
            "https://raw.githubusercontent.com/ltseverydayyou/FNB-playerrrr/refs/heads/main/AutoPlayerRevived.luau",
            "https://tr.rbxcdn.com/180DAY-06421ce8666c82646547498e79a09589/150/150/Image/Png/noFilter",
            null,
            "https://roblox.com/games/7603193259"
        );
        ScriptAdd(
            "Delusional Office",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Delulu%20Office.lua",
            "https://tr.rbxcdn.com/180DAY-dbbcfeee2259d07f20b685e3229c3ac9/256/256/Image/Webp/noFilter",
            null,
            "https://roblox.com/games/18749553947"
        );
        ScriptAdd(
            "Endless Doors",
            "https://raw.githubusercontent.com/ltseverydayyou/endless-doors/main/endless%20madness%20buster",
            "https://tr.rbxcdn.com/180DAY-57bc2bd7eba62e92b90b16d65c33ff71/256/256/Image/Webp/noFilter",
            null,
            "https://roblox.com/games/17324251852"
        );
        ScriptAdd(
            "DeadCoin Farm",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/Be%20Dead%20Forever%20Farm.lua",
            "https://tr.rbxcdn.com/180DAY-995799e88760b15b0611cdd1c818eef5/256/256/Image/Webp/noFilter",
            null,
            "https://roblox.com/games/2882332175"
        );
        ScriptAdd(
            "Project The Rake",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/the%20rake",
            "https://tr.rbxcdn.com/180DAY-b75d323ae9a6c5cd194b708e72c5348f/256/256/Image/Webp/noFilter",
            null,
            "https://roblox.com/games/2413927524"
        );
        ScriptAdd(
            "stupid anticheat bypasser",
            "https://rawscripts.net/raw/Rooms-andamp-Doors-stupid-anticheat-bypasser-31204",
            "https://tr.rbxcdn.com/180DAY-5e9ce9aecc5c87537054147721a1cc7b/256/256/Image/Webp/noFilter",
            null,
            "https://roblox.com/games/5865058321"
        );
        ScriptAdd(
            "Auto Parry (BETA)",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/PhantomBallz.luau",
            "https://tr.rbxcdn.com/180DAY-d39b29f15a839d2561d6b3619d8d8bef/256/256/Image/Webp/noFilter",
            true,
            "https://roblox.com/games/12979690461"
        );
        ScriptAdd(
            "NA Versions Picker",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/NAVerPicker.luau",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/Github_Images/NAverpick.jpg",
            true
        );
        ScriptAdd(
            "Simple Spy Reworked",
            "https://gist.githubusercontent.com/ltseverydayyou/2398adb0db70abc4f752219a676f6cb2/raw/SimpleSpyRework.luau"
        );
        ScriptAdd(
            "Dex ++ (Backup)",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexPlusBackup.luau"
        );
        ScriptAdd(
            "Dex",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/DexByMoonMobile"
        );
        ScriptAdd(
            "Minimap",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/minimap.luau"
        );
        ScriptAdd(
            "Vyperia Aimbot",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/NewAimbot.lua"
        );
        ScriptAdd(
            "Autoclicker",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/AutoClicker.luau"
        );
        ScriptAdd(
            "Chat Translator",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/translatoooor"
        );
        ScriptAdd(
            "Virtual Keyboard",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/VirtualKeyboard.lua"
        );
        ScriptAdd(
            "Turtle Spy",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Turtle%20Spy.lua"
        );
        ScriptAdd(
            "Game Universe Viewer",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Universe%20Viewer"
        );
        ScriptAdd(
            "Mobile Shiftlock",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/shiftlock"
        );
        ScriptAdd(
            "Custom Backpack",
            "https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/refs/heads/main/mobileBACKPACK.lua"
        );
        ScriptAdd(
            "Animation Spoofer",
            "https://raw.githubusercontent.com/ltseverydayyou/Nameless-Admin/refs/heads/main/Animation%20Spoofer"
        );

        const layoutEl = q("#l");
        const fx = q("#fx");
        const avTxt = [
            "GET OUT",
            "hai :3",
            "cuh",
            "guh",
            "fuck off",
            "OUCH",
            ":c",
            "RAHHHHHH",
            "LEGSHOT",
            "cheese",
            "get yo ass off",
            "qipu is a skid (frfr)",
            "downloading ip...",
            "Ragebait Yield"
        ];
        let avLocked = false;
        let avTimestamp = 0;
        let collapseTimer = null;
        let themeFlashTimer = null;
        let themeFlashBackup = null;

        function collapseEverything(duration = 3000) {
            if (!layoutEl) {
                return;
            }
            layoutEl.classList.add("collapsed");
            clearTimeout(collapseTimer);
            collapseTimer = setTimeout(
                () => layoutEl.classList.remove("collapsed"),
                duration
            );
        }

        function resetFlashThemeState() {
            if (themeFlashTimer) {
                clearTimeout(themeFlashTimer);
                themeFlashTimer = null;
            }
            themeFlashBackup = null;
        }

        function flashOuchTheme() {
            const backup = themeFlashBackup || themeGet();
            themeFlashBackup = backup;

            const flashTheme = {
                ...backup,
                g1: "#3c0000",
                g2: "#610000",
                ac: "#ff6b6b",
                ac2: "#ffb3b3"
            };

            themeApply(flashTheme);
            clearTimeout(themeFlashTimer);
            themeFlashTimer = setTimeout(() => {
                if (themeFlashBackup) {
                    themeApply(themeFlashBackup);
                    themeFlashBackup = null;
                    themeFlashTimer = null;
                }
            }, 3000);
        }

        function ripple(el, e) {
            const r = document.createElement("span");
            r.className = "rp";
            const bounds = el.getBoundingClientRect();
            r.style.left = `${e.clientX - bounds.left}px`;
            r.style.top = `${e.clientY - bounds.top}px`;
            el.appendChild(r);
            setTimeout(() => r.remove(), 600);
        }

        function toast(message) {
            const t = q("#ts");
            t.textContent = message;
            t.classList.add("sh");
            clearTimeout(toast._id);
            toast._id = setTimeout(() => t.classList.remove("sh"), 1600);
        }

        function tp(el, txt, spd = 18) {
            el.textContent = "";
            let index = 0;
            const iv = setInterval(() => {
                el.textContent += txt.charAt(index++);
                if (index >= txt.length) {
                    clearInterval(iv);
                }
            }, spd);
        }

        function tab(id) {
            const current = document.querySelector(".pp.on");
            const next = q(`#p${id}`);
            if (id !== "b") {
                setBuilderIconsFullscreen(false);
            }
            qa(".tb").forEach((button) => {
                button.classList.toggle("act", button.dataset.t === id);
            });

            if (current === next) {
                return;
            }

            if (current) {
                current.classList.remove("in");
                current.classList.add("out");
                setTimeout(() => {
                    current.classList.remove("out");
                    current.classList.remove("on");
                }, 200);
            }

            next.classList.add("on");
            next.classList.add("in");
            setTimeout(() => next.classList.remove("in"), 220);
            history.replaceState(null, "", `#${id}`);
        }

        function setBuilderIconsFullscreen(force) {
            const shouldEnable =
                typeof force === "boolean" ? force : !builderIconsFullscreen;
            if (shouldEnable === builderIconsFullscreen) {
                return;
            }

            builderIconsFullscreen = shouldEnable;
            builderIconsSection?.classList.toggle(
                "bi-fullscreen",
                builderIconsFullscreen
            );
            document.body.classList.toggle(
                "bi-buildericons-fullscreen",
                builderIconsFullscreen
            );

            if (builderIconsFullScreenButton) {
                builderIconsFullScreenButton.textContent = builderIconsFullscreen ?
                    "Exit full screen" :
                    "Full screen";
            }
        }

        function onAv() {
            const now = performance.now();
            if (avLocked || now - avTimestamp < 700) {
                return;
            }

            avLocked = true;
            avTimestamp = now;

            const message = avTxt[Math.floor(Math.random() * avTxt.length)];
            const badge = q("#bb");
            badge.classList.add("sh");
            tp(badge, message, 16);

            if (message === "GET OUT") {
                fx.currentTime = 0;
                fx.play().catch(() => {});
                collapseEverything();
            } else if (message === "OUCH") {
                flashOuchTheme();
                q("#av").classList.add("ouch");
                setTimeout(() => q("#av").classList.remove("ouch"), 700);
            }

            setTimeout(() => badge.classList.remove("sh"), 1400);
            setTimeout(() => {
                avLocked = false;
            }, 720);
        }

        const cache = new Map();
        let curCode = "";

        function mOpen(title) {
            q("#mt").textContent = title;
            q("#mb").className = "sk";
            q("#mb").innerHTML = "";
            q("#md").classList.add("sh");
            q("#md").setAttribute("aria-hidden", "false");
        }

        function mClose() {
            q("#md").classList.remove("sh");
            q("#md").setAttribute("aria-hidden", "true");
        }

        async function view(btn) {
            const card = btn.closest(".sc");
            const url = card.dataset.u;
            const name = card.querySelector(".nm").textContent.trim();

            mOpen(name);

            try {
                const content = cache.has(url) ?
                    cache.get(url) :
                    await (await fetch(url, {
                        cache: "no-store"
                    })).text();

                cache.set(url, content);
                curCode = `loadstring(game:HttpGet('${url}'))();\n\n${content}`;

                const pre = document.createElement("pre");
                const code = document.createElement("code");
                code.className = "language-lua";
                code.textContent = content;
                pre.appendChild(code);

                const mb = q("#mb");
                mb.className = "";
                mb.appendChild(pre);
                Prism.highlightElement(code);
            } catch {
                const mb = q("#mb");
                mb.className = "";
                mb.innerHTML = '<div style="padding:16px">Failed to load</div>';
            }
        }

        async function copyLoader(btn) {
            const url = btn.closest(".sc").dataset.u;
            await navigator.clipboard.writeText(
                `loadstring(game:HttpGet('${url}'))();`
            );
            toast("Copied вњ”пёЏ");
        }

        function luaHl() {
            const text = q("#li").value;
            const output = q("#lo");
            output.textContent = text || "-- Highlighted code will appear here";
            Prism.highlightElement(output);

            const count = (pattern) => (text.match(pattern) || []).length;
            const f = count(/\bfunction\b/g);
            const e = count(/\bend\b/g);
            const r = count(/\brepeat\b/g);
            const u = count(/\buntil\b/g);

            const warnings = [];
            if (e < f) {
                warnings.push(`Missing end (${e}/${f})`);
            }
            if (r !== u) {
                warnings.push(`repeat/until (${r}/${u})`);
            }
            if (warnings.length) {
                toast(`вљ пёЏ ${warnings.join(" вЂў ")}`);
            }
        }

        const inlineFunctionRegex = /(function\s*\([^)]*\))\s*return\s*([^\r\n]+?)\s*end/;

        function expandInlineFunctions(line) {
            const lineIndentMatch = line.match(/^(\s*)/);
            const lineIndent = lineIndentMatch ? lineIndentMatch[1] : "";
            let result = line;
            while (true) {
                inlineFunctionRegex.lastIndex = 0;
                const match = inlineFunctionRegex.exec(result);
                if (!match) {
                    break;
                }
                const before = result.slice(0, match.index);
                const suffix = result.slice(match.index + match[0].length);
                const header = match[1].trimEnd();
                const body = match[2].trim();
                result = `${before}${header}\n${lineIndent}    ${body}\n${lineIndent}end${suffix}`;
            }
            return result;
        }

        function splitArguments(argsString) {
            if (!argsString) {
                return [];
            }

            const args = [];
            let buffer = "";
            let depth = 0;
            let braces = 0;
            let brackets = 0;
            let inString = null;
            let escaping = false;

            const pushArgument = () => {
                args.push(buffer);
                buffer = "";
            };

            for (let i = 0; i < argsString.length; i += 1) {
                const char = argsString[i];
                if (escaping) {
                    buffer += char;
                    escaping = false;
                    continue;
                }
                if (inString) {
                    buffer += char;
                    if (char === "\\") {
                        escaping = true;
                    } else if (char === inString) {
                        inString = null;
                    }
                    continue;
                }
                if (char === "'" || char === '"') {
                    inString = char;
                    buffer += char;
                    continue;
                }
                if (char === "\\") {
                    buffer += char;
                    escaping = true;
                    continue;
                }
                if (char === "(") {
                    depth += 1;
                    buffer += char;
                    continue;
                }
                if (char === ")") {
                    depth = Math.max(depth - 1, 0);
                    buffer += char;
                    continue;
                }
                if (char === "{") {
                    braces += 1;
                    buffer += char;
                    continue;
                }
                if (char === "}") {
                    braces = Math.max(braces - 1, 0);
                    buffer += char;
                    continue;
                }
                if (char === "[") {
                    brackets += 1;
                    buffer += char;
                    continue;
                }
                if (char === "]") {
                    brackets = Math.max(brackets - 1, 0);
                    buffer += char;
                    continue;
                }
                if (
                    char === "," &&
                    depth === 0 &&
                    braces === 0 &&
                    brackets === 0 &&
                    !inString
                ) {
                    pushArgument();
                    continue;
                }
                buffer += char;
            }

            if (buffer || argsString.trim().endsWith(",")) {
                args.push(buffer);
            }

            return args;
        }

        function parseCall(text) {
            const firstOpen = text.indexOf("(");
            if (firstOpen === -1) {
                return null;
            }

            let depth = 0;
            let inString = null;
            let escaping = false;
            let closeIndex = -1;

            for (let i = firstOpen; i < text.length; i += 1) {
                const char = text[i];
                if (escaping) {
                    escaping = false;
                    continue;
                }
                if (inString) {
                    if (char === "\\") {
                        escaping = true;
                    } else if (char === inString) {
                        inString = null;
                    }
                    continue;
                }
                if (char === '"' || char === "'") {
                    inString = char;
                    continue;
                }
                if (char === "(") {
                    depth += 1;
                    continue;
                }
                if (char === ")") {
                    depth -= 1;
                    if (depth === 0) {
                        closeIndex = i;
                        break;
                    }
                }
            }

            if (closeIndex === -1) {
                return null;
            }

            return {
                beforeParen: text.slice(0, firstOpen + 1),
                argsString: text.slice(firstOpen + 1, closeIndex),
                afterClose: text.slice(closeIndex + 1)
            };
        }

        function formatCall(entry, indentOverride) {
            const sanitized = entry.trim();
            if (!sanitized) {
                return indentOverride ? `${indentOverride}${sanitized}` : entry;
            }

            const indentMatch = entry.match(/^(\s*)/);
            const baseIndent = indentOverride ?? (indentMatch ? indentMatch[1] : "");
            const parsedCall = parseCall(sanitized);
            if (!parsedCall) {
                return `${baseIndent}${sanitized}`;
            }

            const args = splitArguments(parsedCall.argsString);
            const shouldWrap =
                args.length > 1 &&
                (sanitized.length > 80 ||
                    sanitized.includes("function(") ||
                    args.some((arg) => arg.trim().length > 40));

            if (!shouldWrap) {
                return `${baseIndent}${sanitized}`;
            }

            const lines = [];
            lines.push(`${baseIndent}${parsedCall.beforeParen}`);
            const childIndent = `${baseIndent}    `;
            args.forEach((arg, index) => {
                const trimmedArg = arg.trim();
                if (!trimmedArg) {
                    if (index < args.length - 1) {
                        lines.push(`${childIndent},`);
                    }
                    return;
                }
                const formattedArg = formatCall(trimmedArg, childIndent);
                const parts = formattedArg.split("\n");
                if (index < args.length - 1) {
                    const lastIndex = parts.length - 1;
                    parts[lastIndex] = `${parts[lastIndex]},`;
                }
                lines.push(...parts);
            });
            lines.push(`${baseIndent})${parsedCall.afterClose}`);
            return lines.join("\n");
        }

          function legacyLuaBeautify() {
            const lines = q("#li").value.replace(/\r/g, "").split("\n");
            let depth = 0;
            const formatted = [];

            for (const raw of lines) {
                const trimmed = raw.trim();

                if (/^(end|else|elseif|until)\b/.test(trimmed)) {
                    depth = Math.max(depth - 1, 0);
                }

                const line = `${"  ".repeat(depth)}${trimmed}`;

                if (/^(function|if|for|while|repeat)\b/.test(trimmed)) {
                    depth += 1;
                }

                if (/^(else|elseif)\b/.test(trimmed)) {
                    depth += 1;
                }

                if (/until\b/.test(trimmed)) {
                    depth = Math.max(depth - 1, 0);
                }

                formatted.push(line);
            }

            const expanded = [];
            for (const entry of formatted) {
                const expandedEntry = expandInlineFunctions(entry);
                expanded.push(...expandedEntry.split("\n"));
            }

            const polished = [];
            let buffer = [];

            const appendFormattedLine = (entry) => {
                const formattedLine = formatCall(entry);
                polished.push(...formattedLine.split("\n"));
            };

            const flush = () => {
                if (!buffer.length) {
                    return;
                }

                const aligned = buffer.every((item) => item.includes("="));
                if (aligned) {
                    const maxIndex = Math.max(
                        ...buffer.map((item) => item.indexOf("="))
                    );
                    for (const entry of buffer) {
                        const pivot = entry.indexOf("=");
                        const left = entry
                            .slice(0, pivot)
                            .trimEnd()
                            .padEnd(maxIndex, " ");
                        const right = entry.slice(pivot + 1).trim();
                        appendFormattedLine(`${left} = ${right}`);
                    }
                } else {
                    for (const entry of buffer) {
                        appendFormattedLine(entry);
                    }
                }

                buffer = [];
            };

            for (const entry of expanded) {
                if (entry.trim() === "") {
                    flush();
                    polished.push("");
                } else {
                    buffer.push(entry);
                }
            }
            flush();
    
            q("#li").value = polished.join("\n").trim();
            luaHl();
            toast("Beautified");
          }
    
          async function luaB() {
            const input = q("#li");
            if (!input) {
              return;
            }
            const value = input.value || "";
            if (!value.trim()) {
              toast("Nothing to beautify");
              return;
            }
    
            if (window.Lua5_1) {
              try {
                const formatted = await formatLuaWithFormatLua(value);
                const normalized = formatted
                  .replace(/\r\n/g, "\n")
                  .replace(/\\n/g, "\n")
                  .replace(/^(?:\n)+/, "")
                  .replace(/\s+$/, "");
                input.value = normalized;
                luaHl();
                toast("Beautified with FormatLua");
                return;
              } catch (error) {
                console.error("FormatLua failed", error);
                toast("FormatLua failed, falling back to basic formatter");
              }
            }
    
            legacyLuaBeautify();
          }

        const htmlVoidTags = new Set([
            "area",
            "base",
            "br",
            "col",
            "embed",
            "hr",
            "img",
            "input",
            "link",
            "meta",
            "param",
            "source",
            "track",
            "wbr"
        ]);
        const htmlEmptyPreview =
            '<!doctype html><title>Preview</title><style>html{font:16px system-ui;padding:18px;background:#0b1220;color:#e7e9ee}body{margin:0}</style><h2>Nothing here yet.</h2><p>Start typing to see the preview.</p>';
        const htmlSampleDocument = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Sample</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0b1220;
        color: #f5f5ff;
        margin: 0;
        padding: 32px;
      }
      .card {
        max-width: 460px;
        padding: 24px;
        border-radius: 18px;
        background: linear-gradient(135deg, #66e3ff, #a78bfa);
        color: #0b1220;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.35);
      }
      button {
        border: none;
        border-radius: 999px;
        padding: 10px 22px;
        font-weight: 700;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <main class="card">
      <h1>HTML Playground</h1>
      <p>Edit this sample to test the live preview, formatting, and highlight extras.</p>
      <button>Action</button>
    </main>
  </body>
</html>`;

        function escapeHtmlLite(value) {
            return (value || "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function updateHtmlStatus(message) {
            const statusEl = q("#html-lab-status");
            if (!statusEl) {
                return;
            }
            const stamp = new Date().toLocaleTimeString();
            statusEl.textContent = `${message} • ${stamp}`;
        }

        function htmlR(reason = "manual") {
            const editor = q("#hi");
            const frame = q("#ho");
            if (!editor || !frame) {
                return;
            }
            const html = editor.value.trim();
            frame.srcdoc = html || htmlEmptyPreview;
            renderHtmlStructure(html);
            updateHtmlStatus(
                reason === "auto" ? "Live preview updated" : "Preview refreshed"
            );
        }

        function renderHtmlStructure(html) {
            const treeEl = q("#html-structure");
            const summaryEl = q("#html-structure-summary");
            if (!treeEl) {
                return;
            }

            if (!html) {
                treeEl.innerHTML =
                    '<p class="html-lab__structure-empty">Type HTML to inspect the DOM tree.</p>';
                if (summaryEl) {
                    summaryEl.textContent = "";
                }
                return;
            }

            const template = document.createElement("template");
            template.innerHTML = html;
            const counts = {
                elements: 0,
                text: 0,
                comments: 0
            };
            const fragment = document.createDocumentFragment();
            template.content.childNodes.forEach((node) => {
                const entry = buildHtmlTreeNode(node, 0, counts);
                if (entry) {
                    fragment.appendChild(entry);
                }
            });
            treeEl.innerHTML = "";
            treeEl.appendChild(fragment);
            if (summaryEl) {
                const summaryParts = [
                    `${counts.elements} elements`,
                    `${counts.text} text nodes`
                ];
                if (counts.comments) {
                    summaryParts.push(`${counts.comments} comments`);
                }
                summaryEl.textContent = summaryParts.join(" • ");
            }
        }

        function buildHtmlTreeNode(node, depth, counts) {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.replace(/\s+/g, " ").trim();
                if (!text) {
                    return null;
                }
                counts.text += 1;
                const textEl = document.createElement("div");
                textEl.className = "html-tree__text";
                textEl.textContent = `"${text}"`;
                return textEl;
            }

            if (node.nodeType === Node.COMMENT_NODE) {
                const commentEl = document.createElement("div");
                commentEl.className = "html-tree__comment";
                commentEl.textContent = `<!-- ${node.textContent.trim()} -->`;
                counts.comments += 1;
                return commentEl;
            }

            if (node.nodeType !== Node.ELEMENT_NODE) {
                return null;
            }

            counts.elements += 1;
            const tag = node.tagName.toLowerCase();
            const attrs = Array.from(node.attributes)
                .map((attr) => `${attr.name}="${attr.value}"`)
                .join(" ");
            const details = document.createElement("details");
            details.className = "html-tree__node";
            details.open = depth <= 1;
            const summary = document.createElement("summary");
            summary.textContent = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
            details.appendChild(summary);

            const childrenWrapper = document.createElement("div");
            let hasChildren = false;
            node.childNodes.forEach((child) => {
                const childEntry = buildHtmlTreeNode(child, depth + 1, counts);
                if (childEntry) {
                    hasChildren = true;
                    childrenWrapper.appendChild(childEntry);
                }
            });
            if (hasChildren) {
                details.appendChild(childrenWrapper);
            }

            if (!htmlVoidTags.has(tag)) {
                const closing = document.createElement("div");
                closing.className = "html-tree__closing";
                closing.textContent = `</${tag}>`;
                details.appendChild(closing);
            }

            return details;
        }

        function formatHtmlContent(html) {
            if (!html.trim()) {
                return "";
            }
            const template = document.createElement("template");
            template.innerHTML = html;
            const lines = [];
            template.content.childNodes.forEach((node) => {
                formatHtmlNode(node, 0, lines);
            });
            return lines.join("\n").replace(/\n{3,}/g, "\n\n").trim();
        }

        function formatHtmlNode(node, depth, lines) {
            const indent = "  ".repeat(depth);
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.replace(/\s+/g, " ").trim();
                if (text) {
                    lines.push(`${indent}${text}`);
                }
                return;
            }

            if (node.nodeType === Node.COMMENT_NODE) {
                const comment = node.textContent.trim();
                if (comment) {
                    lines.push(`${indent}<!-- ${comment} -->`);
                }
                return;
            }

            if (node.nodeType !== Node.ELEMENT_NODE) {
                return;
            }

            const tag = node.tagName.toLowerCase();
            const attrs = Array.from(node.attributes)
                .map((attr) => `${attr.name}="${attr.value}"`)
                .join(" ");
            const openTag = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
            const isVoid = htmlVoidTags.has(tag);
            lines.push(`${indent}${openTag}`);
            if (isVoid) {
                return;
            }

            const children = Array.from(node.childNodes);
            if (
                (tag === "script" || tag === "style") &&
                children.length === 1 &&
                children[0].nodeType === Node.TEXT_NODE
            ) {
                const scriptText = children[0].textContent.replace(/\r/g, "");
                if (scriptText.trim()) {
                    scriptText
                        .split("\n")
                        .map((line) => line.trim())
                        .filter(Boolean)
                        .forEach((line) => lines.push(`${indent}  ${line}`));
                }
            } else {
                children.forEach((child) => formatHtmlNode(child, depth + 1, lines));
            }
            lines.push(`${indent}</${tag}>`);
        }

        function htmlFormatCurrent() {
            const editor = q("#hi");
            if (!editor) {
                return;
            }
            let formatted = "";
            try {
                formatted = formatHtmlContent(editor.value);
            } catch {
                formatted = "";
            }
            if (!formatted) {
                toast("Nothing to format");
                return;
            }
            editor.value = formatted;
            htmlR("manual");
            toast("HTML formatted");
        }

          function htmlOpenPreviewWindow() {
            const editor = q("#hi");
            if (!editor) {
              return;
            }
            const htmlContent = editor.value || htmlEmptyPreview;
            const blob = new Blob([htmlContent], { type: "text/html" });
            const url = URL.createObjectURL(blob);
            const previewWindow = window.open(url, "_blank", "noopener");
            if (!previewWindow) {
              URL.revokeObjectURL(url);
              toast("Popup blocked");
              return;
            }
            const revoke = () => {
              URL.revokeObjectURL(url);
              previewWindow.removeEventListener("beforeunload", revoke);
            };
            previewWindow.addEventListener("beforeunload", revoke);
          }

          function htmlOpenHighlightWindow() {
            const editor = q("#hi");
            if (!editor) {
              return;
            }
            const highlighted = escapeHtmlLite(
                editor.value || "<!-- Nothing to highlight -->"
            );
            const highlightHtml = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Highlighted HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <style>
      body { margin: 0; background: #0b1220; color: #e7e9ee; font-family: ui-monospace, Consolas, monospace; }
      pre { margin: 0; padding: 24px; overflow: auto; }
    </style>
  </head>
  <body>
    <pre><code class="language-markup">${highlighted}</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"><\/script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"><\/script>
  </body>
</html>`;
            const blob = new Blob([highlightHtml], { type: "text/html" });
            const url = URL.createObjectURL(blob);
            const highlightWindow = window.open(url, "_blank", "noopener");
            if (!highlightWindow) {
              URL.revokeObjectURL(url);
              toast("Popup blocked");
              return;
            }
            const revoke = () => {
              URL.revokeObjectURL(url);
              highlightWindow.removeEventListener("beforeunload", revoke);
            };
            highlightWindow.addEventListener("beforeunload", revoke);
          }

        function htmlSetTreeExpansion(expand) {
            qa("#html-structure details").forEach((entry) => {
                entry.open = expand;
            });
        }

        function htmlInsertSample() {
            const editor = q("#hi");
            if (!editor) {
                return;
            }
            editor.value = htmlSampleDocument;
            htmlR("manual");
            toast("Sample inserted");
        }

        function htmlClearEditor() {
            const editor = q("#hi");
            if (!editor) {
                return;
            }
            editor.value = "";
            htmlR("manual");
            toast("HTML cleared");
        }

        function htmlImportFromFile(file) {
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = () => {
                const editor = q("#hi");
                if (!editor) {
                    return;
                }
                editor.value = reader.result;
                htmlR("manual");
                toast(`Imported ${file.name}`);
            };
            reader.onerror = () => toast("Import failed");
            reader.readAsText(file);
        }

        function htmlExportCurrent() {
            const editor = q("#hi");
            if (!editor) {
                return;
            }
            const blob = new Blob([editor.value], {
                type: "text/html"
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "vyperia-html-playground.html";
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 1500);
            toast("Exported HTML");
        }

        const rddBaseUrl = "https://ltseverydayyou.github.io/rdd/";
        const rddBinaryPlatformMap = {
            WindowsPlayer: "Windows",
            WindowsStudio64: "Windows",
            MacPlayer: "Mac",
            MacStudio: "Mac"
        };

        const rddElements = {
            binary: q("#rdd-binary"),
            channel: q("#rdd-channel"),
            version: q("#rdd-version"),
            compress: q("#rdd-compress"),
            compression: q("#rdd-compression"),
            launcher: q("#rdd-launcher"),
            preview: q("#rdd-link-preview"),
            status: q("#rdd-status"),
            downloadSpecific: q("#rdd-download-specific"),
            downloadLatest: q("#rdd-download-latest"),
            downloadPrevious: q("#rdd-download-previous"),
            copyLink: q("#rdd-copy-link")
        };

        function sanitizeRddChannel(value) {
            const trimmed = value.trim();
            return trimmed || "LIVE";
        }

        function sanitizeRddVersion(value) {
            if (!value) {
                return "";
            }
            let cleaned = value.trim().toLowerCase();
            if (!cleaned) {
                return "";
            }
            if (!cleaned.startsWith("version-")) {
                cleaned = `version-${cleaned}`;
            }
            return cleaned;
        }

        function clampCompression(value) {
            const num = parseInt(value, 10);
            if (Number.isNaN(num)) {
                return 5;
            }
            return Math.min(9, Math.max(1, num));
        }

        function buildRddLink(versionOverride) {
            const params = new URLSearchParams();
            params.set("channel", sanitizeRddChannel(rddElements.channel?.value || ""));
            params.set("binaryType", rddElements.binary?.value || "WindowsPlayer");

            const versionValue = versionOverride || sanitizeRddVersion(rddElements.version?.value || "");
            if (versionValue) {
                params.set("version", versionValue);
            }

            const compressEnabled = !!rddElements.compress?.checked;
            if (compressEnabled) {
                const level = clampCompression(rddElements.compression?.value || "5");
                params.set("compressZip", "true");
                params.set("compressionLevel", String(level));
            }

            if (rddElements.launcher?.checked) {
                params.set("includeLauncher", "true");
            }

            return {
                url: `${rddBaseUrl}?${params.toString()}`,
                version: versionValue
            };
        }

        function updateRddPreview() {
            if (!rddElements.preview) {
                return;
            }
            const {
                url,
                version
            } = buildRddLink();
            if (version) {
                rddElements.preview.innerHTML = `<a href="${url}" target="_blank" rel="noopener">${url}</a>`;
            } else {
                rddElements.preview.textContent =
                    "Add a version hash or use one of the quick download buttons to generate a link.";
            }
        }

        function setRddStatus(message, isError = false) {
            if (!rddElements.status) {
                return;
            }
            rddElements.status.textContent = message;
            rddElements.status.style.color = isError ? "#ff8484" : "";
        }

        async function fetchRddVersion(endpoint, platformKey) {
            const response = await fetch(`https://weao.gg/api/versions/${endpoint}`);
            if (!response.ok) {
                throw new Error(`Unable to fetch ${endpoint} versions (${response.status})`);
            }
            const payload = await response.json();
            const key = platformKey === "Mac" ? "Mac" : "Windows";
            const versionHash = payload[key];
            if (!versionHash) {
                throw new Error("Version data unavailable for the selected binary type.");
            }
            return versionHash;
        }

        function openRddWindow(url) {
            const win = window.open(url, "_blank", "noopener");
            if (!win) {
                toast("Popup blocked. Please allow popups for this site.");
            } else {
                setRddStatus("Opened download link in a new tab.");
            }
        }

        async function handleRddAutoDownload(endpoint, button) {
            if (!button || !rddElements.binary) {
                return;
            }
            const binaryType = rddElements.binary.value;
            const platformKey = rddBinaryPlatformMap[binaryType];
            if (!platformKey) {
                toast("Select a binary type first.");
                return;
            }
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = "Fetching...";
            setRddStatus("Fetching version information...");
            try {
                const versionHash = await fetchRddVersion(endpoint, platformKey);
                rddElements.version.value = versionHash;
                updateRddPreview();
                const link = buildRddLink(versionHash);
                openRddWindow(link.url);
            } catch (error) {
                console.error(error);
                setRddStatus(error.message, true);
                toast("Unable to fetch version info right now.");
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        function themeGet() {
            const styles = getComputedStyle(document.documentElement);
            return {
                ac: styles.getPropertyValue("--ac").trim() || "#66e3ff",
                ac2: styles.getPropertyValue("--ac2").trim() || "#a78bfa",
                g1: styles.getPropertyValue("--g1").trim() || "#0b1220",
                g2: styles.getPropertyValue("--g2").trim() || "#111c2e",
                glA: styles.getPropertyValue("--glA").trim() || "0.06",
                bdA: styles.getPropertyValue("--bdA").trim() || "0.12",
                rad: styles.getPropertyValue("--rad").trim() || "16px",
                fs: parseInt(styles.fontSize, 10) || 15
            };
        }

        function themeApply(theme) {
            const root = document.documentElement;
            root.style.setProperty("--ac", theme.ac);
            root.style.setProperty("--ac2", theme.ac2);
            root.style.setProperty("--g1", theme.g1);
            root.style.setProperty("--g2", theme.g2);
            root.style.setProperty("--glA", theme.glA);
            root.style.setProperty("--bdA", theme.bdA);
            root.style.setProperty(
                "--rad",
                typeof theme.rad === "number" ? `${theme.rad}px` : theme.rad
            );
            root.style.fontSize = `${theme.fs || 15}px`;
        }

        function themeSave() {
            resetFlashThemeState();
            const theme = themeGet();
            themeApply(theme);
            localStorage.setItem("th", JSON.stringify(theme));
            toast("Theme saved вњ”пёЏ");
        }

        function themeLoad() {
            resetFlashThemeState();
            const saved = localStorage.getItem("th");
            if (!saved) {
                return;
            }

            try {
                const parsed = JSON.parse(saved);
                themeApply(parsed);
                q("#c_ac").value = parsed.ac;
                q("#c_ac2").value = parsed.ac2;
                q("#c_g1").value = parsed.g1;
                q("#c_g2").value = parsed.g2;
                q("#r_gl").value = parsed.glA;
                q("#r_bd").value = parsed.bdA;
                q("#n_rad").value = parseInt(parsed.rad, 10) || 16;
                q("#n_fs").value = parsed.fs || 15;
            } catch {
                // ignore
            }
        }

        function themeDefaults() {
            resetFlashThemeState();
            const defaults = {
                ac: "#66e3ff",
                ac2: "#a78bfa",
                g1: "#0b1220",
                g2: "#111c2e",
                glA: "0.06",
                bdA: "0.12",
                rad: "16px",
                fs: 15
            };

            themeApply(defaults);
            localStorage.removeItem("th");

            q("#c_ac").value = defaults.ac;
            q("#c_ac2").value = defaults.ac2;
            q("#c_g1").value = defaults.g1;
            q("#c_g2").value = defaults.g2;
            q("#r_gl").value = defaults.glA;
            q("#r_bd").value = defaults.bdA;
            q("#n_rad").value = parseInt(defaults.rad, 10);
            q("#n_fs").value = defaults.fs;

            toast("Theme reset");
        }

        function themeApplyFromUi() {
            resetFlashThemeState();
            const theme = {
                ac: q("#c_ac").value,
                ac2: q("#c_ac2").value,
                g1: q("#c_g1").value,
                g2: q("#c_g2").value,
                glA: q("#r_gl").value,
                bdA: q("#r_bd").value,
                rad: `${q("#n_rad").value}px`,
                fs: parseInt(q("#n_fs").value, 10) || 15
            };
            themeApply(theme);
            toast("Applied");
        }

        function initBuilderIcons() {
            const loadingScreenElement = document.getElementById(
                "bi-loading-screen"
            );
            const loadingTextElement = document.getElementById("bi-loading-text");
            const gridElement = document.getElementById("bi-grid");
            const toolbarHintElement = document.querySelector(".bi-toolbar__hint");
            const searchInputElement = document.getElementById("bi-search");

            if (
                !loadingScreenElement ||
                !loadingTextElement ||
                !gridElement ||
                !window.opentype
            ) {
                return;
            }

            let builderIconEntries = [];

            const escapeHtml = (value) =>
                (value || "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");

            const createBuilderIconElement = (entryData) => {
                const componentsMarkup = entryData.hasDistinctComponents ?
                    `<div class="bi-entry__components">Components: ${escapeHtml(
                    entryData.componentsLabel
                  )}</div>` :
                    "";

                const entryElement = document.createElement("article");
                entryElement.className = "bi-entry";
                entryElement.setAttribute("role", "listitem");
                entryElement.innerHTML = `
                <div class="bi-entry__glyphs">
                  <span class="bi-entry__glyph" aria-hidden="true">${escapeHtml(
                    entryData.unicodeCharacter
                  )}</span>
                  <span class="bi-entry__glyph bi-entry__glyph--bold" aria-hidden="true">${escapeHtml(
                    entryData.unicodeCharacter
                  )}</span>
                </div>
                <div class="bi-entry__glyph-labels">
                  <span>Regular</span>
                  <span>Bold</span>
                </div>
                <div class="bi-entry__meta">
                  <span>#${entryData.displayIndex}</span>
                  <span>${entryData.codePointLabel}</span>
                </div>
                <div class="bi-entry__name" title="${escapeHtml(
                  entryData.displayName
                )}">
                  ${escapeHtml(entryData.displayName)}
                </div>
                ${componentsMarkup}
                <div class="bi-entry__actions">
                  <button type="button" class="pl bi-entry__copy">Copy name</button>
                </div>
              `;

                const copyButton = entryElement.querySelector(".bi-entry__copy");
                if (copyButton) {
                    const defaultLabel = copyButton.textContent || "Copy name";
                    let resetTimer;

                    const resetCopyButton = () => {
                        copyButton.textContent = defaultLabel;
                        copyButton.classList.remove("bi-entry__copy--success");
                    };

                    copyButton.addEventListener("click", async () => {
                        try {
                            await navigator.clipboard.writeText(entryData.displayName);
                            copyButton.textContent = "Copied!";
                            copyButton.classList.add("bi-entry__copy--success");
                            toast("Icon name copied");
                        } catch {
                            copyButton.textContent = "Copy failed";
                            toast("Copy failed");
                        } finally {
                            clearTimeout(resetTimer);
                            resetTimer = setTimeout(resetCopyButton, 1400);
                        }
                    });
                }

                return entryElement;
            };

            const renderBuilderIconGrid = (filterValue = "") => {
                const normalizedFilter = (filterValue || "").trim().toLowerCase();
                const activeEntries = normalizedFilter ?
                    builderIconEntries.filter((entry) =>
                        entry.searchText.includes(normalizedFilter)
                    ) :
                    builderIconEntries;

                gridElement.innerHTML = "";

                if (!activeEntries.length) {
                    const emptyMessage = document.createElement("div");
                    emptyMessage.className = "bi-grid__empty";
                    emptyMessage.textContent = normalizedFilter ?
                        `No icons match "${filterValue}"` :
                        "No icons found";
                    gridElement.appendChild(emptyMessage);
                } else {
                    const fragment = document.createDocumentFragment();
                    activeEntries.forEach((entryData) => {
                        fragment.appendChild(createBuilderIconElement(entryData));
                    });
                    gridElement.appendChild(fragment);
                }

                if (toolbarHintElement) {
                    const hintMessage = normalizedFilter ?
                        `Showing ${activeEntries.length} of ${builderIconEntries.length} icons` :
                        `Showing ${builderIconEntries.length} icons`;
                    toolbarHintElement.textContent = hintMessage;
                }
            };

            if (searchInputElement) {
                const handleSearchInput = (event) => {
                    renderBuilderIconGrid(event.target.value);
                };
                searchInputElement.addEventListener("input", handleSearchInput);
                searchInputElement.addEventListener("search", handleSearchInput);
            }

            let loadingText = "";
            let loadingTextDotCount = 0;

            function updateLoadingText() {
                loadingTextElement.textContent =
                    loadingText + ".".repeat(loadingTextDotCount);
            }

            setInterval(() => {
                loadingTextDotCount += 1;
                if (loadingTextDotCount > 3) {
                    loadingTextDotCount = 0;
                }
                updateLoadingText();
            }, 500);

            function setLoadingScreenText(text) {
                if (text) {
                    loadingText = text;
                    updateLoadingText();
                    loadingScreenElement.style.display = "flex";
                    gridElement.style.display = "none";
                } else {
                    loadingScreenElement.style.display = "none";
                    gridElement.style.display = "grid";
                }
            }

            function sleepAsync(time) {
                return new Promise((resolve) => setTimeout(resolve, time));
            }

            async function fetchFontBuffer(url) {
                while (true) {
                    try {
                        const resp = await fetch(url);
                        return await resp.arrayBuffer();
                    } catch {
                        await sleepAsync(1000);
                    }
                }
            }

            (async function() {
                setLoadingScreenText("Fetching font files");

                const baseURL =
                    "https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/refs/heads/roblox/LuaPackages/Packages/_Index/BuilderIcons/BuilderIcons/Font/";

                const regularFontBuffer = await fetchFontBuffer(
                    `${baseURL}BuilderIcons-Regular.ttf`
                );
                const filledFontBuffer = await fetchFontBuffer(
                    `${baseURL}BuilderIcons-Filled.ttf`
                );

                setLoadingScreenText("Parsing font files");

                document.fonts.add(
                    new FontFace("BuilderIcons", regularFontBuffer, {
                        weight: "normal"
                    })
                );
                document.fonts.add(
                    new FontFace("BuilderIcons", filledFontBuffer, {
                        weight: "bold"
                    })
                );

                const regularFontData = opentype.parse(regularFontBuffer);
                const filledFontData = opentype.parse(filledFontBuffer);

                const entries = [];

                function scanFont(font) {
                    const glyphsData = font.glyphs;

                    font.tables?.gsub?.lookups?.forEach((lookup) => {
                        lookup.subtables?.forEach((subtable) => {
                            const coverageGlyphs = subtable.coverage?.glyphs;
                            subtable.ligatureSets?.forEach(
                                (ligatureSet, ligatureSetIndex) => {
                                    ligatureSet.forEach((ligatureData) => {
                                        const componentsString = [
                                                coverageGlyphs?.[ligatureSetIndex],
                                                ...ligatureData.components
                                            ]
                                            .map((value) =>
                                                String.fromCodePoint(
                                                    glyphsData.get(value)?.unicode ?? 0
                                                )
                                            )
                                            .join("");

                                        if (
                                            !entries.find(
                                                (entryData) =>
                                                entryData.components === componentsString
                                            )
                                        ) {
                                            entries.push({
                                                components: componentsString,
                                                unicode: glyphsData.get(ligatureData.ligGlyph ?? 0)
                                                    ?.unicode ?? 0,
                                                label: glyphsData.get(ligatureData.ligGlyph ?? 0)?.name ||
                                                    componentsString
                                            });
                                        }
                                    });
                                }
                            );
                        });
                    });

                    for (let index = 0; index < glyphsData.length; index++) {
                        const glyphData = glyphsData.get(index);
                        const glyphName = glyphData?.name;
                        const glyphUnicode = glyphData?.unicode;
                        const glyphCodepoint = glyphData?.unicodes.find(
                            (value) => value !== glyphUnicode
                        );

                        if (
                            glyphName &&
                            glyphCodepoint != null &&
                            !entries.find(
                                (entryData) => entryData.components === glyphName
                            )
                        ) {
                            entries.push({
                                components: glyphName,
                                unicode: glyphCodepoint,
                                label: glyphName
                            });
                        }
                    }
                }

                scanFont(regularFontData);
                scanFont(filledFontData);

                entries.sort((entryA, entryB) => {
                    const nameA = entryA.components || "";
                    const nameB = entryB.components || "";
                    return nameA.localeCompare(nameB);
                });

                builderIconEntries = entries.map((entryData, index) => {
                    const unicodeCodepoint = entryData.unicode || 0;
                    const unicodeCharacter = unicodeCodepoint ?
                        String.fromCodePoint(unicodeCodepoint) :
                        "";
                    const displayName =
                        entryData.label ||
                        entryData.components ||
                        `Glyph ${index + 1}`;
                    const componentsLabel = entryData.components || "";
                    const codePointLabel = `U+${unicodeCodepoint
                  .toString(16)
                  .toUpperCase()
                  .padStart(4, "0")}`;
                    const searchText = `${displayName} ${componentsLabel} ${codePointLabel}`.toLowerCase();

                    return {
                        displayIndex: index + 1,
                        displayName,
                        componentsLabel,
                        hasDistinctComponents:
                            !!componentsLabel && componentsLabel !== displayName,
                        unicodeCharacter,
                        codePointLabel,
                        searchText
                    };
                });

                setLoadingScreenText(null);
                if (searchInputElement) {
                    searchInputElement.disabled = false;
                }

                renderBuilderIconGrid(searchInputElement ? searchInputElement.value : "");
            })();
        }

        window.addEventListener("DOMContentLoaded", () => {
            renderHome();
            renderScripts();
            initScriptSearcher();
            initVersionCards();
            versionSpecs.forEach(fetchVersionData);
            setExecutorFilter("all");
            loadExecutorStatuses();

            const executorTabs = qa(".executor-tab");
            executorTabs.forEach((tab) => {
                tab.addEventListener("click", (event) => {
                    ripple(tab, event);
                    setExecutorFilter(tab.dataset.filter);
                });
            });

            qa(".tb").forEach((button) => {
                button.addEventListener("click", (event) => {
                    ripple(button, event);
                    tab(button.dataset.t);
                });
            });

            const init = location.hash.slice(1) || "h";
            tab(init);

            q("#av").addEventListener("click", onAv);

            const broadcastExecBtn = q("#broadcast-open-executors");
            if (broadcastExecBtn) {
                broadcastExecBtn.addEventListener("click", () => {
                    tab("e");
                });
            }

            const heroScriptsBtn = q("#hero-open-scripts");
            if (heroScriptsBtn) {
                heroScriptsBtn.addEventListener("click", () => {
                    tab("s");
                });
            }

            const heroExecBtn = q("#hero-open-executors");
            if (heroExecBtn) {
                heroExecBtn.addEventListener("click", () => {
                    tab("e");
                });
            }

            const heroCardExecBtn = q("#hero-card-open-executors");
            if (heroCardExecBtn) {
                heroCardExecBtn.addEventListener("click", () => {
                    tab("e");
                });
            }

            document.addEventListener("click", (event) => {
                const btn = event.target.closest("[data-a],[data-game]");
                if (!btn) {
                    return;
                }
                ripple(btn, event);
                if (btn.dataset.a === "v") {
                    view(btn);
                } else if (btn.dataset.a === "c") {
                    copyLoader(btn);
                } else if (btn.dataset.game) {
                    window.open(btn.dataset.game, "_blank", "noopener,noreferrer");
                }
            });

            const btnX = q("#x");
            btnX.addEventListener("click", (event) => {
                ripple(btnX, event);
                mClose();
            });

            q("#md").addEventListener("click", (event) => {
                if (event.target.id === "md") {
                    mClose();
                }
            });

            const btnCP = q("#cp");
            btnCP.addEventListener("click", async (event) => {
                ripple(btnCP, event);
                if (!curCode) {
                    return;
                }
                await navigator.clipboard.writeText(curCode);
                toast("Script copied вњ”пёЏ");
            });

            const bHL = q("#lhl");
            bHL.addEventListener("click", (event) => {
                ripple(bHL, event);
                luaHl();
            });

            const bBF = q("#lbf");
            if (bBF) {
              const beautifyLabel = bBF.textContent || "Beautify";
              bBF.addEventListener("click", async (event) => {
                ripple(bBF, event);
                const previousLabel = bBF.textContent || beautifyLabel;
                bBF.disabled = true;
                bBF.textContent = "Beautifying...";
                try {
                  await luaB();
                } finally {
                  bBF.disabled = false;
                  bBF.textContent = previousLabel;
                }
              });
            }

            if (builderIconsFullScreenButton) {
                builderIconsFullScreenButton.addEventListener("click", (event) => {
                    ripple(builderIconsFullScreenButton, event);
                    setBuilderIconsFullscreen();
                });
            }

            const bEX = q("#executor-refresh");
            if (bEX) {
                bEX.addEventListener("click", (event) => {
                    ripple(bEX, event);
                    loadExecutorStatuses();
                });
            }

            document.addEventListener("keydown", (event) => {
                if (event.key === "Escape" && builderIconsFullscreen) {
                    setBuilderIconsFullscreen(false);
                }
            });

            const htmlEditor = q("#hi");
            const queueHtmlPreview = debounce(() => htmlR("auto"), 450);
            if (htmlEditor) {
                htmlEditor.addEventListener("input", () => {
                    updateHtmlStatus("Queued live preview...");
                    queueHtmlPreview();
                });
            }

            const bHR = q("#hr");
            if (bHR) {
                bHR.addEventListener("click", (event) => {
                    ripple(bHR, event);
                    htmlR();
                });
            }

            const htmlPreviewWindowBtn = q("#html-preview-window");
            if (htmlPreviewWindowBtn) {
                htmlPreviewWindowBtn.addEventListener("click", (event) => {
                    ripple(htmlPreviewWindowBtn, event);
                    htmlOpenPreviewWindow();
                });
            }

            const htmlHighlightWindowBtn = q("#html-highlight-window");
            if (htmlHighlightWindowBtn) {
                htmlHighlightWindowBtn.addEventListener("click", (event) => {
                    ripple(htmlHighlightWindowBtn, event);
                    htmlOpenHighlightWindow();
                });
            }

            const htmlFormatBtn = q("#html-format");
            if (htmlFormatBtn) {
                htmlFormatBtn.addEventListener("click", (event) => {
                    ripple(htmlFormatBtn, event);
                    htmlFormatCurrent();
                });
            }

            const htmlExpandBtn = q("#html-expand");
            if (htmlExpandBtn) {
                htmlExpandBtn.addEventListener("click", (event) => {
                    ripple(htmlExpandBtn, event);
                    htmlSetTreeExpansion(true);
                });
            }

            const htmlCollapseBtn = q("#html-collapse");
            if (htmlCollapseBtn) {
                htmlCollapseBtn.addEventListener("click", (event) => {
                    ripple(htmlCollapseBtn, event);
                    htmlSetTreeExpansion(false);
                });
            }

            const htmlSampleBtn = q("#html-sample");
            if (htmlSampleBtn) {
                htmlSampleBtn.addEventListener("click", (event) => {
                    ripple(htmlSampleBtn, event);
                    htmlInsertSample();
                });
            }

            const htmlClearBtn = q("#html-clear");
            if (htmlClearBtn) {
                htmlClearBtn.addEventListener("click", (event) => {
                    ripple(htmlClearBtn, event);
                    htmlClearEditor();
                });
            }

            const htmlImportInput = q("#html-import");
            const htmlImportTrigger = q("#html-import-trigger");
            if (htmlImportTrigger && htmlImportInput) {
                htmlImportTrigger.addEventListener("click", (event) => {
                    ripple(htmlImportTrigger, event);
                    htmlImportInput.click();
                });
                htmlImportInput.addEventListener("change", (event) => {
                    const files = event.target.files;
                    htmlImportFromFile(files && files[0] ? files[0] : null);
                    event.target.value = "";
                });
            }

            const htmlExportBtn = q("#html-export");
            if (htmlExportBtn) {
                htmlExportBtn.addEventListener("click", (event) => {
                    ripple(htmlExportBtn, event);
                    htmlExportCurrent();
                });
            }

            const htmlStructureRefresh = q("#html-refresh-structure");
            if (htmlStructureRefresh) {
                htmlStructureRefresh.addEventListener("click", (event) => {
                    ripple(htmlStructureRefresh, event);
                    renderHtmlStructure(((htmlEditor && htmlEditor.value) || "").trim());
                    updateHtmlStatus("Structure synced");
                });
            }

            renderHtmlStructure(((htmlEditor && htmlEditor.value) || "").trim());
            htmlR("manual");

            const rddInputs = [
                rddElements.binary,
                rddElements.channel,
                rddElements.version,
                rddElements.compress,
                rddElements.compression,
                rddElements.launcher
            ];
            rddInputs.forEach((input) => {
                if (!input) {
                    return;
                }
                input.addEventListener("input", () => {
                    if (input === rddElements.compression) {
                        input.value = String(clampCompression(input.value));
                    }
                    updateRddPreview();
                });
            });
            updateRddPreview();
            setRddStatus("Ready.");

            if (rddElements.downloadSpecific) {
                rddElements.downloadSpecific.addEventListener("click", () => {
                    const link = buildRddLink();
                    if (!link.version) {
                        setRddStatus("Enter a version hash first.", true);
                        toast("Enter a version hash first.");
                        return;
                    }
                    setRddStatus(`Opening ${link.version}...`);
                    openRddWindow(link.url);
                });
            }

            if (rddElements.downloadLatest) {
                rddElements.downloadLatest.addEventListener("click", () => {
                    handleRddAutoDownload("current", rddElements.downloadLatest);
                });
            }

            if (rddElements.downloadPrevious) {
                rddElements.downloadPrevious.addEventListener("click", () => {
                    handleRddAutoDownload("past", rddElements.downloadPrevious);
                });
            }

            if (rddElements.copyLink) {
                rddElements.copyLink.addEventListener("click", async () => {
                    const link = buildRddLink();
                    if (!link.version) {
                        setRddStatus("Add a version hash before copying the link.", true);
                        toast("Add a version hash before copying.");
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(link.url);
                        toast("RDD link copied.");
                        setRddStatus(`Copied link for ${link.version}.`);
                    } catch {
                        toast("Clipboard permissions denied.");
                        setRddStatus("Clipboard permissions denied.", true);
                    }
                });
            }

            const bTA = q("#t_apply");
            bTA.addEventListener("click", (event) => {
                ripple(bTA, event);
                themeApplyFromUi();
            });

            const bTS = q("#t_save");
            bTS.addEventListener("click", (event) => {
                ripple(bTS, event);
                themeSave();
            });

            const bTR = q("#t_reset");
            bTR.addEventListener("click", (event) => {
                ripple(bTR, event);
                themeDefaults();
            });

            themeLoad();
            initBuilderIcons();
        });
    </script>
</body>

</html>
